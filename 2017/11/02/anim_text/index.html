<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta name="keywords" content="hexo, autumn, android, video, audio, 音视频, 动画">
    <title>
        Life is Like A Boat
    </title>
    <!-- favicon -->
    
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/favicon.ico">
     <link rel="stylesheet" href="/css/style.css">

    <!-- highlight -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css">
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
    <script src="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@2.0.0/dist/main.js"></script>

    <script>
        infiniteScroll()

        window.addEventListener('DOMContentLoaded', function () {
            const [
                mainTitle,
                mobileMenu,
                mobileMainTitle,
                mobileMenuBtn,
                ipadMenuBtn,
                aside,
                closeBtn,
            ] = getEle(
                '#main-title',
                '.mobile-menu',
                '.mobile-menu h3',
                '.mobile-menu button',
                '.ipad-menu',
                'aside',
                'aside .close',
            )
            const io = new IntersectionObserver(entries => {
                if (entries[0].intersectionRatio <= 0) {
                    mobileMainTitle.classList.remove('invisibile')
                } else {
                    mobileMainTitle.classList.add('invisibile')
                }
            })
            io.observe(mainTitle)

            clickToggleAside(mobileMenuBtn)
            clickToggleAside(ipadMenuBtn)
            clickToggleAside(closeBtn, false)

            const isMenuVisible = window.getComputedStyle(mobileMenu).display !== 'none'
            if (isMenuVisible) document.body.style.background = 'none'

            function getEle(...args) {
                return args.map(arg => document.querySelector(arg))
            }

            function clickToggleAside(btn, show = true) {
                btn.addEventListener('click', function () {
                    if (show) {
                        aside.style.display = 'block'
                    } else {
                        aside.style.display = 'none'
                    }
                })
            }
        })
    </script>
</head>

<body style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
    <div class="container">
        <header class="header">
    <nav class="mobile-menu" style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
        <h3 class="invisibile">
            <a href="/" class="logo">
                Life is Like A Boat
            </a>
        </h3>
        <button class="menu">menu</button>
    </nav>

    <button class="ipad-menu menu">menu</button>

    <h1 class="title" id="main-title">
        <a href="/" class="logo">
            Life is Like A Boat
        </a>
    </h1>
    <h2 class="desc">
        Silent
    </h2>

    <div class="links">
        <ul>
            
            <li>
                <a href="https://github.com/JadynAi/">
                    Github
                </a>
            </li>
            
            <li>
                <a href="https://juejin.im/user/566d95f260b2ed36d9580add">
                    掘金
                </a>
            </li>
            
        </ul>
    </div>
</header>
        <main class="main">
            <article class="post">
    
    
    <h4 class="post-cat">
        <a href="/categories/Android/">
            Android
        </a>
    </h4>
    
    
    <h2 class="post-title">
        文字动次打次，让文字动态绘制出来
    </h2>
    <ul class="post-date">
        <li>
            2017-11-02
        </li>
        <li>
            AiLo
        </li>
    </ul>
    <div class="post-content">
        <p><em>本文属于Android技术论述文章，阅读完大致需要五分钟</em>   </p>
<blockquote>
<p>原创文章，转载请注明出处。 </p>
</blockquote>
<p><strong>没时间的小伙伴可以直接跳过文章，<a href="https://github.com/JadynAi/LoadingLovely/tree/master/app/src/main/java/com/example/jadynai/loadinglovely/animtext" target="_blank" rel="noopener">点击项目地址</a>，如果喜欢的话，顺手给个star那是极好的【娇羞……】</strong></p>
<h4 id="二话不说，效果奉上！"><a href="#二话不说，效果奉上！" class="headerlink" title="二话不说，效果奉上！"></a>二话不说，效果奉上！</h4><p><img src="https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/anim_text.gif" alt></p>
<h4 id="知识点序列："><a href="#知识点序列：" class="headerlink" title="知识点序列："></a>知识点序列：</h4><ul>
<li>Canvas绘制</li>
<li>TextPaint</li>
<li>Path</li>
<li>PathMeasure【测量Path】</li>
</ul>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="获取文字的轮廓Path"><a href="#获取文字的轮廓Path" class="headerlink" title="获取文字的轮廓Path"></a>获取文字的轮廓Path</h5><p>在<code>TextPaint</code>中有这样一个方法，<code>getTextPath</code>,如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void getTextPath(String text, int start, int end,</span><br><span class="line">                            float x, float y, Path path) &#123;</span><br><span class="line">        if ((start | end | (end - start) | (text.length() - end)) &lt; 0) &#123;</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        nGetTextPath(mNativePaint, mNativeTypeface, mBidiFlags, text, start, end, x, y,</span><br><span class="line">                path.mutateNI());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>👀其中<code>nGetTextPath</code>里面是调用了一个原生函数，具体实现不必理会。只需要了解函数的各个参数就可以了。</p>
<ul>
<li>参数含义：<ul>
<li>text：文本内容</li>
<li>start：需要测量的文本中的第一个字符的下标</li>
<li>end：需要测量的文本最后一个字符的下标加1</li>
<li>x：Path起点的坐标X</li>
<li>y：Path起点的坐标Y</li>
<li>path：最终测量得到的Path  </li>
</ul>
</li>
</ul>
<h4 id="Path分段绘制"><a href="#Path分段绘制" class="headerlink" title="Path分段绘制"></a>Path分段绘制</h4><p><a href="http://blog.csdn.net/eclipsexys/article/details/51992473" target="_blank" rel="noopener">PathMeasure</a>这个类可以说是Path相关的工具解析类，里面大多是原生函数，实现细节不必深究。只需要会使用方法即可。<br>第一步我们得到文字的轮廓Path之后，这一步将此path按段绘制出来即可。在代码中，由<code>CanvasView</code>这个类来具体实现绘制的详尽流程。看代码，将文本轮廓Path设置进来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 保留一份原始Path，用作绘制最终填色的文字</span><br><span class="line">     mOrignalPath = orignalPath;</span><br><span class="line">     if (null == mPathMeasure) &#123;</span><br><span class="line">         mPathMeasure = new PathMeasure();</span><br><span class="line">     &#125;</span><br><span class="line">     //先重置一下需要显示动画的path</span><br><span class="line">     mAnimPath.reset();</span><br><span class="line">     mAnimPath.moveTo(0, 0);</span><br><span class="line">     mPathMeasure.setPath(orignalPath, false);</span><br><span class="line">     // getLength（）方法获得的是当前path的长度；而nextContour（）方法是将Path切换到下一段Path，多应用在复杂path中</span><br><span class="line">     mTextCount = 0;</span><br><span class="line">     // 计算文字总共有多少段Path</span><br><span class="line">     while (mPathMeasure.nextContour()) &#123;</span><br><span class="line">         mTextCount++;</span><br><span class="line">     &#125;</span><br><span class="line">     // PathMeasure重新设置一次</span><br><span class="line">     mPathMeasure.setPath(orignalPath, false);</span><br><span class="line">     mPaint.setStyle(Paint.Style.STROKE);</span><br></pre></td></tr></table></figure>
<ul>
<li>其中成员变量mAnimPath，即是用在<code>onDraw()</code>方法内用于绘制的Path。我们会不停地通过<code>PathMeasure</code>刷新这个Path，用于动画流畅运行。</li>
</ul>
<p>接下来是引擎代码，使用的是属性动画，看代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">if (null == mValueAnimator) &#123;</span><br><span class="line">            // 如果一个文本Path包含n个小Path，那么属性动画会Repeat运行n次，每一段小path默认动画时间为900ms</span><br><span class="line">            mValueAnimator = ValueAnimator.ofFloat(0.0f, 1.0f);</span><br><span class="line">            mValueAnimator.setDuration(900);</span><br><span class="line">            mValueAnimator.setInterpolator(new LinearInterpolator());</span><br><span class="line">        &#125;</span><br><span class="line">        // 引擎无限次重复发动</span><br><span class="line">        mValueAnimator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">                float value = (float) animation.getAnimatedValue();</span><br><span class="line">                // 将一段小Path从0%到100%赋值到mAnimPath中，调用重绘</span><br><span class="line">                mPathMeasure.getSegment(0, mPathMeasure.getLength() * value, mAnimPath, true);</span><br><span class="line">                invalidate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        mValueAnimator.addListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationRepeat(Animator animation) &#123;</span><br><span class="line">                super.onAnimationRepeat(animation);</span><br><span class="line">                //绘制完一条Path之后，再绘制下一条，直到完成为止。</span><br><span class="line">                if (!mPathMeasure.nextContour()) &#123;</span><br><span class="line">                    animation.end();</span><br><span class="line">                &#125;</span><br><span class="line">                invalidate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>注释里具体原因亦已写明。这种引擎的设置，就是每一小段Path不管长短，其绘制时间都是相等的，会造成动画看起来时慢时快。</li>
<li>其实要让动画一直匀速跑起来也很容易，就是提前将原始Path测量一遍，设置一个总时间，然后根据小Path的长短来按照比例分配时间。这样即可使动画匀速进行。具体代码不再多言😘，有兴趣的小伙伴可以试试。</li>
</ul>
<p>再看看<code>CanvasView</code>内的<code>onDraw()</code>方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        if (null != mPathMeasure &amp;&amp; mPathMeasure.getLength() == 0) &#123;</span><br><span class="line">            mPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">            canvas.drawPath(mOrignalPath, mPaint);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.drawPath(mAnimPath, mPaint);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里面的代码更加简单，在Path绘制完之前，一直绘制mAnimPath即可。Path绘制完之后，设置画笔的绘制风格，将文字空白处填上色即可。</li>
</ul>
<h3 id="以上。就是本次项目的主要思路解析。大家走过路过不要错过，给添个Star呗😄。"><a href="#以上。就是本次项目的主要思路解析。大家走过路过不要错过，给添个Star呗😄。" class="headerlink" title="以上。就是本次项目的主要思路解析。大家走过路过不要错过，给添个Star呗😄。"></a>以上。就是本次项目的主要思路解析。大家走过路过不要错过，给添个<a href="https://github.com/JadynAi/LoadingLovely/tree/master/app/src/main/java/com/example/jadynai/loadinglovely/animtext" target="_blank" rel="noopener">Star</a>呗😄。</h3>
    </div>
</article>
        </main>
        <aside class="aside">
            <div class="close"></div>
            <section class="aside-section">
                
    <h1>Categories</h1>

    <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/音视频/">音视频</a></li></ul>

            </section>
            <section class="aside-section">
                
    <h1>Archives</h1>

    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a></li></ul>


            </section>
            <section class="aside-section tag">
                
    <h1>Tags</h1>

    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Camera2/">Camera2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Canvas动画/">Canvas动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MediaCodeC/">MediaCodeC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/交互体验/">交互体验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术讨论/">技术讨论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/科普向/">科普向</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/视觉设计/">视觉设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/视频/">视频</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/音视频/">音视频</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/音频/">音频</a></li></ul>

            </section>
        </aside>
    </div>
</body>

</html>