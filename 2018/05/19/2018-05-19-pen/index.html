<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta name="keywords" content="hexo, autumn, android, video, audio, 音视频, 动画">
    <title>
        Life is Like A Boat
    </title>
    <!-- favicon -->
    
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/favicon.ico">
     <link rel="stylesheet" href="/css/style.css">

    <!-- highlight -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css">
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
    <script src="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@2.0.0/dist/main.js"></script>

    <script>
        infiniteScroll()

        window.addEventListener('DOMContentLoaded', function () {
            const [
                mainTitle,
                mobileMenu,
                mobileMainTitle,
                mobileMenuBtn,
                ipadMenuBtn,
                aside,
                closeBtn,
            ] = getEle(
                '#main-title',
                '.mobile-menu',
                '.mobile-menu h3',
                '.mobile-menu button',
                '.ipad-menu',
                'aside',
                'aside .close',
            )
            const io = new IntersectionObserver(entries => {
                if (entries[0].intersectionRatio <= 0) {
                    mobileMainTitle.classList.remove('invisibile')
                } else {
                    mobileMainTitle.classList.add('invisibile')
                }
            })
            io.observe(mainTitle)

            clickToggleAside(mobileMenuBtn)
            clickToggleAside(ipadMenuBtn)
            clickToggleAside(closeBtn, false)

            const isMenuVisible = window.getComputedStyle(mobileMenu).display !== 'none'
            if (isMenuVisible) document.body.style.background = 'none'

            function getEle(...args) {
                return args.map(arg => document.querySelector(arg))
            }

            function clickToggleAside(btn, show = true) {
                btn.addEventListener('click', function () {
                    if (show) {
                        aside.style.display = 'block'
                    } else {
                        aside.style.display = 'none'
                    }
                })
            }
        })
    </script>
</head>

<body style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
    <div class="container">
        <header class="header">
    <nav class="mobile-menu" style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
        <h3 class="invisibile">
            <a href="/" class="logo">
                Life is Like A Boat
            </a>
        </h3>
        <button class="menu">menu</button>
    </nav>

    <button class="ipad-menu menu">menu</button>

    <h1 class="title" id="main-title">
        <a href="/" class="logo">
            Life is Like A Boat
        </a>
    </h1>
    <h2 class="desc">
        Silent
    </h2>

    <div class="links">
        <ul>
            
            <li>
                <a href="https://github.com/JadynAi/">
                    Github
                </a>
            </li>
            
            <li>
                <a href="https://juejin.im/user/566d95f260b2ed36d9580add">
                    掘金
                </a>
            </li>
            
        </ul>
    </div>
</header>
        <main class="main">
            <article class="post">
    
    
    <h4 class="post-cat">
        <a href="/categories/Android/">
            Android
        </a>
    </h4>
    
    
    <h2 class="post-title">
        基于Java代码实现的喷漆笔刷
    </h2>
    <ul class="post-date">
        <li>
            2018-05-19
        </li>
        <li>
            AiLo
        </li>
    </ul>
    <div class="post-content">
        <p><strong>原创文章，转载请联系作者</strong></p>
<blockquote>
<p>软草平莎过雨新，轻沙走马路无尘。<br>何时收拾耦耕身？</p>
</blockquote>
<p>先上效果图：<br><img src="https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/pen.gif" alt></p>
<p><a href="https://github.com/JadynAi/LoadingLovely/tree/master/app/src/main/java/com/example/jadynai/loadinglovely/pen" target="_blank" rel="noopener">笔刷项目地址</a>在此，大家要是喜欢的话，不妨来点个赞吧</p>
<h3 id="效果解析"><a href="#效果解析" class="headerlink" title="效果解析"></a>效果解析</h3><p>因为最终要实现的是<code>windwos</code>下的画板喷漆笔刷，所以首先要对它做一个较为详细的效果解析。考虑到笔一般情况下笔刷的使用点，故此会分析一下<strong>点</strong>和<strong>线</strong>的效果细节。</p>
<ul>
<li>画点<br><br><img src="https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/pen_1.jpg" alt></li>
</ul>
<blockquote>
<p>从左至右依次是对同一坐标点击2次，点击8次，点击16次的效果展示；<br>当数量趋向更大时，点的密集程度并没有很明显的偏向，基本可以确定要在圆内均匀分布</p>
</blockquote>
<ul>
<li>画线<br><img src="https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/pen_0.jpg" alt></li>
</ul>
<blockquote>
<p>如图为匀速且缓慢滑过时，由点构成线</p>
</blockquote>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>项目的大致框架由<code>View</code>、<code>BasePen</code>，两个大的模块构成。其中<code>View</code>属于UI层面，<code>BasePen</code>属于业务逻辑层面。接下来，将一一介绍这两个模块的具体功用和细节。</p>
<h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><p>此项目的承载View为<code>PenView</code>，不承担业务逻辑，就是起到一个容器的作用。在<code>PenView</code>中唯一的作用就是触发<code>invalidate（）</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private BasePen mBasePen;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</span><br><span class="line">        super.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">        if (w != 0 &amp;&amp; h != 0) &#123;</span><br><span class="line">            if (mBasePen == null) &#123;</span><br><span class="line">                mBasePen = new SprayPen(w, h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        MotionEvent event1 = MotionEvent.obtain(event);</span><br><span class="line">        mBasePen.onTouchEvent(event1);</span><br><span class="line">        switch (event.getActionMasked()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                invalidate();</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        mBasePen.onDraw(canvas);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>具体的业务逻辑，绘制、数据计算、触摸点移动Move等，全都由<code>BasePen</code>以及它的子类来实现了。<br>低耦合性，代表着更多的自由度，对现有项目代码（如果应用到项目中）的冲击更小。在性能方面，如果<code>View</code>满足不了要求，可以用更小的代价将其移植到性能更好的<code>SurfaceView</code>里去。</p>
<h4 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h4><p>业务方面，<code>BasePen</code>作为基类，承担了一些基础的数据计算、绘制等功能，而具体的画笔效果则交由子类实现。<br>先看看<code>BasePen</code>里做了什么：</p>
<ul>
<li>绘制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;Point&gt; mPoints;</span><br><span class="line">public void onDraw(Canvas canvas) &#123;</span><br><span class="line">        if (mPoints != null &amp;&amp; !mPoints.isEmpty()) &#123;</span><br><span class="line">            canvas.drawBitmap(mBitmap, 0, 0, null);</span><br><span class="line">            drawDetail(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>先将笔刷绘制到一张<code>Bitmap</code>之上，再将这张<code>Bitmap</code>交给<code>PenView</code>来绘制出来。<code>Point</code>是一个只记录了x和y坐标的类。<br><code>drawDetail(Canvas canvas)</code>是一个抽象类，由子类实现具体的绘制。</p>
<ul>
<li><p>滑动轨迹<br>在<code>BasePen</code>的<code>onTouchEvent(MotionEvent event1)</code>方法里。以每次<code>DOWN</code>事件为开始，记录<code>MOVE</code>内的所有坐标信息。考虑到喷漆效果基本不用处理<strong>笔锋效果</strong>，暂不考虑记录<code>UP</code>信息（后续如果实现其他笔刷效果会优化这里）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void onTouchEvent(MotionEvent event1) &#123;</span><br><span class="line">        switch (event1.getActionMasked()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                clearPoints();</span><br><span class="line">                handlePoints(event1);</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                handlePoints(event1);</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void handlePoints(MotionEvent event1) &#123;</span><br><span class="line">        float x = event1.getX();</span><br><span class="line">        float y = event1.getY();</span><br><span class="line">        if (x &gt; 0 &amp;&amp; y &gt; 0) &#123;</span><br><span class="line">            mPoints.add(new Point(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void clearPoints() &#123;</span><br><span class="line">        if (mPoints == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mPoints.clear();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>喷漆实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void drawDetail(Canvas canvas) &#123;</span><br><span class="line">        if (getPoints().isEmpty()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mTotalNum = 由自定义粒子密度以及画笔宽度计算而来</span><br><span class="line">        drawSpray(当前最新坐标点.x, 当前最新坐标点.y, mTotalNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void drawSpray(float x, float y, int totalNum) &#123;</span><br><span class="line">        for (int i = 0; i &lt; totalNum; i++) &#123;</span><br><span class="line">        	//算法计算出圆内随机点</span><br><span class="line">            float[] randomPoint = getRandomPoint(x, y, mPenW, true);</span><br><span class="line">            mCanvas.drawCircle(randomPoint[0], randomPoint[1], mCricleR, mPaint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>以上是一部分伪代码，<code>SprayPen</code>内部定义了一个喷漆粒子密度，会根据画笔的宽度来实时改变粒子数量。每个粒子的半径则由外部依赖的组件提供的<code>width</code>计算而来。<br>在<code>drawDetail(...)</code>方法内，每一次<code>MOVE</code>和<code>DOWN</code>事件都会在相应坐标处，绘制一定数目的圆内随机点。<br>当其串联起来时，就形成了喷漆效果。当然这只是初步完成，还有一些算法需要完善。伪代码表述不全，可参考<a href="https://github.com/JadynAi/LoadingLovely/blob/master/app/src/main/java/com/example/jadynai/loadinglovely/pen/SprayPen.java" target="_blank" rel="noopener">SprayPen</a>，在代码中有比较完善的注释。</p>
</blockquote>
<p>接下来会说一些有关喷漆算法方面的问题。</p>
<h3 id="喷漆算法的几个问题"><a href="#喷漆算法的几个问题" class="headerlink" title="喷漆算法的几个问题"></a>喷漆算法的几个问题</h3><p>在实现功能的过程中，有两个问题是值得记录的。<br>一是圆内均匀随机点的分布问题；二是滑动速度快时，笔画的连接处理问题。</p>
<h4 id="如何均匀的在圆内生成随机点"><a href="#如何均匀的在圆内生成随机点" class="headerlink" title="如何均匀的在圆内生成随机点"></a>如何均匀的在圆内生成随机点</h4><p>为了解决这个问题，主要尝试了三种方法：</p>
<h5 id="x在-R-R-范围内随机取值，由圆解析式求解得y。然后对y在-y-y-内随机取值，得到的点即为圆内点。同理，也可由y计算出x。"><a href="#x在-R-R-范围内随机取值，由圆解析式求解得y。然后对y在-y-y-内随机取值，得到的点即为圆内点。同理，也可由y计算出x。" class="headerlink" title="x在(-R,R)范围内随机取值，由圆解析式求解得y。然后对y在(-y,y)内随机取值，得到的点即为圆内点。同理，也可由y计算出x。"></a>x在(-R,R)范围内随机取值，由圆解析式<img src="https://images0.cnblogs.com/blog/517264/201410/142127248732998.png" alt>求解得y。然后对y在(-y,y)内随机取值，得到的点即为圆内点。同理，也可由y计算出x。</h5><p>java代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float x = mRandom.nextInt(r);</span><br><span class="line">float y = (float) Math.sqrt(Math.pow(r, 2) - Math.pow(x, 2));</span><br><span class="line">y = mRandom.nextInt((int) y);</span><br><span class="line">x = 对值随机取正负(x);</span><br><span class="line">y = 对值随机取正负(y);</span><br></pre></td></tr></table></figure>
<p>最终呈现效果如下：<br><img src="https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/pen_2.jpg" alt></p>
<blockquote>
<p>当样本数量达到2000时，形状如上所示<br>可以很明显的看到，在x轴方向，左右两端的密集程度明显高于圆心<br>随机值在大量数据下会具有规律性，可以理解为当数据很多时，x的取值在(-r,r)大致为均匀分布的，y的取值亦是。当处于左右两端时，y的取值范围变小，视觉效果就显得紧凑了些。<br>当然如果用概率论数理统计公式来验证会更有说服力，但可惜不会。。。（耸肩）</p>
</blockquote>
<h5 id="随机角度，在-0-360-内随机取得角度，然后在-0-r-范围内随机取值，然后使用sin和cos来求解x和y。"><a href="#随机角度，在-0-360-内随机取得角度，然后在-0-r-范围内随机取值，然后使用sin和cos来求解x和y。" class="headerlink" title="随机角度，在[0,360)内随机取得角度，然后在[0,r]范围内随机取值，然后使用sin和cos来求解x和y。"></a>随机角度，在[0,360)内随机取得角度，然后在[0,r]范围内随机取值，然后使用<code>sin</code>和<code>cos</code>来求解x和y。</h5><p>java代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float[] ints = new float[2];</span><br><span class="line">int degree = mRandom.nextInt(360);</span><br><span class="line">double curR = mRandom.nextInt(r)+1;</span><br><span class="line">float x = (float) (curR * Math.cos(Math.toRadians(degree)));</span><br><span class="line">float y = (float) (curR * Math.sin(Math.toRadians(degree)));</span><br><span class="line">x = 对值随机取正负(x);</span><br><span class="line">y = 对值随机取正负(y);</span><br></pre></td></tr></table></figure></p>
<p>最终呈现效果如下：<br><img src="https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/pen_3.jpg" alt></p>
<blockquote>
<p>明显看到中心处的密集程度高于边缘地带，事实上当角度固定时，r在[0,R)范围内随机取值。当数量更大时，坐标点是均匀分布的。<br>当r越小时，所占用的面积越小，就会显得粒子很密集。</p>
</blockquote>
<h4 id="随机角度，在-0-360-内随机取得角度，取-0-1-内的随机平方根再和R相乘，然后使用sin和cos来求解x和y。"><a href="#随机角度，在-0-360-内随机取得角度，取-0-1-内的随机平方根再和R相乘，然后使用sin和cos来求解x和y。" class="headerlink" title="随机角度，在[0,360)内随机取得角度，取[0,1]内的随机平方根再和R相乘，然后使用sin和cos来求解x和y。"></a>随机角度，在[0,360)内随机取得角度，取[0,1]内的随机平方根再和R相乘，然后使用<code>sin</code>和<code>cos</code>来求解x和y。</h4><p>java代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int degree = mRandom.nextInt(360);</span><br><span class="line">double curR = Math.sqrt(mRandom.nextDouble()) * r;</span><br><span class="line">float x = (float) (curR * Math.cos(Math.toRadians(degree)));</span><br><span class="line">float y = (float) (curR * Math.sin(Math.toRadians(degree)));</span><br><span class="line">x = 对值随机取正负(x);</span><br><span class="line">y = 对值随机取正负(y);</span><br></pre></td></tr></table></figure></p>
<p>最终呈现效果如下：<br><img src="https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/pen_4.jpg" alt></p>
<blockquote>
<p>这次的视觉效果总算是达到了<strong>均匀</strong>的效果，这个算法是利用了一个根函数的特性，如下图:<img src="https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/pen_5.jpg" alt>红色是根函数，蓝色是线性函数。两者相比下来，根函数的取值会更大些，相应的，接近边缘的点就会更多一点，让粒子的分布效果更加均衡。</p>
</blockquote>
<h3 id="处理“奋笔疾书”情况"><a href="#处理“奋笔疾书”情况" class="headerlink" title="处理“奋笔疾书”情况"></a>处理“奋笔疾书”情况</h3><p>当以比较慢的速度滑动时，笔画尚显流畅无明显断层。当速度过快时，<code>MOVE</code>留下的点更少，且间距大。会出现画笔断层现象，这时候就需要一些特殊的处理方法。<br><br>代码中设定了一个标准值<code>D</code>，这个值是由<code>BasePen</code>所持有的<strong>w</strong>和<strong>h</strong>两个值计算而来的，一般来说，这两个值期望为依附的<code>View</code>的宽高。<code>最初也考虑使用画笔的直径计算，但考虑到画笔直径是可以外部动态改变的。标准值最好保持一定的独立性，其所依赖的数据越稳定越好，要不然会影响平衡</code>。然后当<code>MOVE</code>时，当前点距离上一个点的相对距离大于这个标准值<code>D</code>时，就会判定此时处于快移速状态，间距越大移速越快，那么喷漆效果相应地就要减弱【直观而言就是粒子浓度要低】。<br>快移速状态时，代码会在当前点和上一个点之间，模拟出一些<strong>笔迹点</strong>。相应地，这些笔迹点的粒子密集度会低一些，其计算函数且是一个反驼峰的变化状态。即<strong>连续笔迹点</strong>的中间点粒子最稀疏，两边则最密集。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> //手速过快时</span><br><span class="line">float stepDis = mPenR * 1.6f;</span><br><span class="line">//笔迹点的数量</span><br><span class="line">int v = (int) (getLastDis() / stepDis);</span><br><span class="line">float gapX = getPoints().get(getPoints().size() - 1).x - getPoints().get(getPoints().size() - 2).x;</span><br><span class="line">float gapY = getPoints().get(getPoints().size() - 1).y - getPoints().get(getPoints().size() - 2).y;</span><br><span class="line">//描绘笔迹点</span><br><span class="line">for (int i = 1; i &lt;= v; i++) &#123;</span><br><span class="line"> 	float x = (float) (getPoints().get(getPoints().size() - 2).x + (gapX * i * stepDis / getLastDis()));</span><br><span class="line">    float y = (float) (getPoints().get(getPoints().size() - 2).y + (gapY * i * stepDis / getLastDis()));</span><br><span class="line">    drawSpray(x, y, (int) (mTotalNum * calculate(i, 1, v)), mRandom.nextBoolean());</span><br><span class="line">            &#125;</span><br><span class="line">/**</span><br><span class="line">     * 使用（x-（min+max）/2)^2/（min-（min+max）/2）^2作为粒子密度比函数</span><br><span class="line">     */</span><br><span class="line">    private static float calculate(int index, int min, int max) &#123;</span><br><span class="line">        float maxProbability = 0.6f;</span><br><span class="line">        float minProbability = 0.15f;</span><br><span class="line">        if (max - min + 1 &lt;= 4) &#123;</span><br><span class="line">            return maxProbability;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (max + min) / 2;</span><br><span class="line">        int maxValue = (int) Math.pow(mid - min, 2);</span><br><span class="line">        float ratio = (float) (Math.pow(index - mid, 2) / maxValue);</span><br><span class="line">        if (ratio &gt;= maxProbability) &#123;</span><br><span class="line">            return maxProbability;</span><br><span class="line">        &#125; else if (ratio &lt;= minProbability) &#123;</span><br><span class="line">            return minProbability;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ratio;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>本项目在写的时候，顺便也写了一个<code>Kotlin</code>版本的。注意，并不是用AS自带的代码转换的。所以<code>Kotlin</code>版本会有很多不必要的测试体验代码，不要在意这些细节。<br><a href="https://github.com/JadynAi/LoadingLovely/tree/master/app/src/main/java/com/example/jadynai/loadinglovely/pen/kotlin" target="_blank" rel="noopener">Kotlin版本</a>这里这里，喜欢的不妨点个赞吧</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是本次<code>Demo</code>的思路、以及一些算法的解析。数学之美，令人沉醉<em>（数学学渣留下了悔恨的泪水。。。）</em><br><strong>数学才是本体啊</strong><br><a href="https://github.com/JadynAi/LoadingLovely/tree/master/app/src/main/java/com/example/jadynai/loadinglovely/pen" target="_blank" rel="noopener">笔刷项目地址</a>在此，代码中的注释会更加清晰些，大家要是喜欢的话，不妨来点个赞吧</p>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ul>
<li><a href="http://www.cnblogs.com/TenosDoIt/p/4025221.html" target="_blank" rel="noopener">均匀的生成圆和三角形内的随机点</a></li>
</ul>

    </div>
</article>
        </main>
        <aside class="aside">
            <div class="close"></div>
            <section class="aside-section">
                
    <h1>Categories</h1>

    <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/音视频/">音视频</a></li></ul>

            </section>
            <section class="aside-section">
                
    <h1>Archives</h1>

    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a></li></ul>


            </section>
            <section class="aside-section tag">
                
    <h1>Tags</h1>

    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Camera2/">Camera2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Canvas动画/">Canvas动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MediaCodeC/">MediaCodeC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/交互体验/">交互体验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术讨论/">技术讨论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/科普向/">科普向</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/视觉设计/">视觉设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/视频/">视频</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/音视频/">音视频</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/音频/">音频</a></li></ul>

            </section>
        </aside>
    </div>
</body>

</html>