<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta name="keywords" content="hexo, autumn, android, video, audio, 音视频, 动画">
    <title>
        Life is Like A Boat
    </title>
    <!-- favicon -->
    
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/favicon.ico">
     <link rel="stylesheet" href="/css/style.css">

    <!-- highlight -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css">
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
    <script src="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@2.0.0/dist/main.js"></script>

    <script>
        infiniteScroll()

        window.addEventListener('DOMContentLoaded', function () {
            const [
                mainTitle,
                mobileMenu,
                mobileMainTitle,
                mobileMenuBtn,
                ipadMenuBtn,
                aside,
                closeBtn,
            ] = getEle(
                '#main-title',
                '.mobile-menu',
                '.mobile-menu h3',
                '.mobile-menu button',
                '.ipad-menu',
                'aside',
                'aside .close',
            )
            const io = new IntersectionObserver(entries => {
                if (entries[0].intersectionRatio <= 0) {
                    mobileMainTitle.classList.remove('invisibile')
                } else {
                    mobileMainTitle.classList.add('invisibile')
                }
            })
            io.observe(mainTitle)

            clickToggleAside(mobileMenuBtn)
            clickToggleAside(ipadMenuBtn)
            clickToggleAside(closeBtn, false)

            const isMenuVisible = window.getComputedStyle(mobileMenu).display !== 'none'
            if (isMenuVisible) document.body.style.background = 'none'

            function getEle(...args) {
                return args.map(arg => document.querySelector(arg))
            }

            function clickToggleAside(btn, show = true) {
                btn.addEventListener('click', function () {
                    if (show) {
                        aside.style.display = 'block'
                    } else {
                        aside.style.display = 'none'
                    }
                })
            }
        })
    </script>
</head>

<body style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
    <div class="container">
        <header class="header">
    <nav class="mobile-menu" style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
        <h3 class="invisibile">
            <a href="/" class="logo">
                Life is Like A Boat
            </a>
        </h3>
        <button class="menu">menu</button>
    </nav>

    <button class="ipad-menu menu">menu</button>

    <h1 class="title" id="main-title">
        <a href="/" class="logo">
            Life is Like A Boat
        </a>
    </h1>
    <h2 class="desc">
        Silent
    </h2>

    <div class="links">
        <ul>
            
            <li>
                <a href="https://github.com/JadynAi/">
                    Github
                </a>
            </li>
            
            <li>
                <a href="https://juejin.im/user/566d95f260b2ed36d9580add">
                    掘金
                </a>
            </li>
            
        </ul>
    </div>
</header>
        <main class="main">
            <article class="post">
    
    
    <h4 class="post-cat">
        <a href="/categories/Python/">
            Python
        </a>
    </h4>
    
    
    <h2 class="post-title">
        使用A*算法求解机器人迷宫最短路径
    </h2>
    <ul class="post-date">
        <li>
            2018-07-29
        </li>
        <li>
            AiLo
        </li>
    </ul>
    <div class="post-content">
        <p><strong>原创文章，转载请联系作者</strong></p>
<blockquote>
<p>时光只解催人老，不信多情，长恨离亭，泪滴春衫酒易醒。</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近接触了一个挺有意思的小课题，跟大家分享一下。就是利用<code>A*</code>算法，来计算迷宫可行路径。有关这个算法的知识，大家可以看看<br><a href="https://zh.wikipedia.org/wiki/A*%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">A星算法维基百科</a>以及<a href="https://blog.csdn.net/hitwhylz/article/details/23089415" target="_blank" rel="noopener">A星算法详解</a>来稍作了解。<br>代码地址在此<a href="https://github.com/JadynAi/Python_D/blob/master/venv/include/maze/AStarRobot.py" target="_blank" rel="noopener">Maze</a>,喜欢<code>Python</code>的小可爱们可以拿去练练手。</p>
<h3 id="提要说明"><a href="#提要说明" class="headerlink" title="提要说明"></a>提要说明</h3><p>本题中的迷宫，是以宫格类型呈现的，在代码中的呈现为<code>二维数组</code>。其次在迷宫中的移动，也只有<strong>上、下、左、右</strong>四个动作可选。如下所示：</p>
<blockquote>
<p>其中<strong>1</strong>代表入口，<strong>2</strong>代表障碍物不可通行，<strong>3</strong>代表出口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[3, 2, 2, 2, 2, 2, 2, 2, 1],</span><br><span class="line"> [0, 0, 2, 2, 2, 2, 2, 0, 0],</span><br><span class="line"> [2, 0, 0, 2, 2, 2, 0, 0, 2],</span><br><span class="line"> [2, 2, 0, 0, 2, 0, 0, 2, 2],</span><br><span class="line"> [2, 2, 2, 0, 0, 0, 2, 2, 2]]</span><br></pre></td></tr></table></figure>
<p>其实在<code>A*算法</code>中，对单位搜索区域的描述为–<code>节点nodes</code>。在本题中，我们可以把搜索区域视为正方形，会更简单一点。</p>
<h3 id="A-算法逻辑解析"><a href="#A-算法逻辑解析" class="headerlink" title="A*算法逻辑解析"></a>A*算法逻辑解析</h3><p><code>A*算法</code>的逻辑其实并不是很难，简化起来就是两个词：<strong>评估</strong>、<strong>循环</strong>。<br>从起点开始行动，首先找到起点周围可以行走的<code>节点</code>，然后在这个节点中，<code>评估</code>出距离终点最优（最短）的<code>节点</code>。那么这个<code>最优</code>节点，将作为下一步行动的点，以此类推，直至找到终点。<br>可以看到，在这个逻辑中，其实最重要的就是<code>评估</code>这一步了。<code>A*算法</code>的评估函数为：<br><code>f(n) = g(n) + h(n)</code><br></p>
<blockquote>
<p><code>g(n)</code>–代表移动到这个点的代价，在本题中均为1.因为只可以水平或者数值运动。要是斜角可以移动的话，那么这个值就为<code>√2</code><br><br><code>h(n)</code>–从这个点移动到终点的代价，这是一个猜测值。本题中，将迷宫视作坐标系的话，那么<code>h(n)</code>就是取和终点x、y各自差值的最小者。譬如点[4,2]和终点[1,1]的<code>h(n)</code>取值为：1</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码中对点的描述，均为实际值，并非以0为开始值计算。</p>
<h4 id="定位起点和终点，使用列表存储四个移动命令，以下代码env-data代表迷宫数组："><a href="#定位起点和终点，使用列表存储四个移动命令，以下代码env-data代表迷宫数组：" class="headerlink" title="定位起点和终点，使用列表存储四个移动命令，以下代码env_data代表迷宫数组："></a>定位起点和终点，使用列表存储四个移动命令，以下代码<code>env_data</code>代表迷宫数组：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 上下左右四个移动命令，只具备四个移动命令</span><br><span class="line">orders = [&apos;u&apos;, &apos;d&apos;, &apos;l&apos;, &apos;r&apos;]</span><br><span class="line"></span><br><span class="line"># 定位起点和终点</span><br><span class="line">start_loc = []</span><br><span class="line">des_loc = []</span><br><span class="line">for index, value in enumerate(env_data, 1):</span><br><span class="line">    if len(start_loc) == 0 or len(des_loc) != 0:</span><br><span class="line">        if 1 in value:</span><br><span class="line">            start_loc = (index, value.index(1) + 1)</span><br><span class="line">        if 3 in value:</span><br><span class="line">            des_loc = (index, value.index(3) + 1)</span><br><span class="line">    else:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
<h4 id="判断节点所有可执行的移动命令："><a href="#判断节点所有可执行的移动命令：" class="headerlink" title="判断节点所有可执行的移动命令："></a>判断节点所有可执行的移动命令：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def valid_actions(loc):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :param loc:</span><br><span class="line">    :return: 当前位置所有可用的命令</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    loc_actions = []</span><br><span class="line">    for order in orders:</span><br><span class="line">        if is_move_valid(loc, order):</span><br><span class="line">            loc_actions.append(order)</span><br><span class="line">    return loc_actions</span><br><span class="line"></span><br><span class="line">def is_move_valid(loc, act):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    判断当前点，是否可使用此移动命令</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    x = loc[0] - 1</span><br><span class="line">    y = loc[1] - 1</span><br><span class="line">    if act not in orders:</span><br><span class="line">        return false</span><br><span class="line">    else:</span><br><span class="line">        if act == orders[0]:</span><br><span class="line">            return x != 0 and env_data[x - 1][y] != 2</span><br><span class="line">        elif act == orders[1]:</span><br><span class="line">            return x != len(env_data) - 1 and env_data[x + 1][y] != 2</span><br><span class="line">        elif act == orders[2]:</span><br><span class="line">            return y != 0 and env_data[x][y - 1] != 2</span><br><span class="line">        else:</span><br><span class="line">            return y != len(env_data[0]) - 1 and env_data[x][y + 1] != 2</span><br></pre></td></tr></table></figure>
<h4 id="拿到节点周围移动单位为1的所有可到达点-不包括此节点："><a href="#拿到节点周围移动单位为1的所有可到达点-不包括此节点：" class="headerlink" title="拿到节点周围移动单位为1的所有可到达点,不包括此节点："></a>拿到节点周围移动单位为<code>1</code>的所有可到达点,不包括此节点：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def get_all_valid_loc(loc):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    计算当前点，附近所有可用的点</span><br><span class="line">    :param loc:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    all_valid_data = []</span><br><span class="line">    cur_acts = valid_actions(loc)</span><br><span class="line">    for act in cur_acts:</span><br><span class="line">        all_valid_data.append(move_robot(loc, act))</span><br><span class="line">    if loc in all_valid_data:</span><br><span class="line">        all_valid_data.remove(loc)</span><br><span class="line">    return all_valid_data</span><br><span class="line">    </span><br><span class="line">def move_robot(loc, act):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    移动机器人，返回新位置</span><br><span class="line">    :param loc:</span><br><span class="line">    :param act:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if is_move_valid(loc, act):</span><br><span class="line">        if act == orders[0]:</span><br><span class="line">            return loc[0] - 1, loc[1]</span><br><span class="line">        elif act == orders[1]:</span><br><span class="line">            return loc[0] + 1, loc[1]</span><br><span class="line">        elif act == orders[2]:</span><br><span class="line">            return loc[0], loc[1] - 1</span><br><span class="line">        else:</span><br><span class="line">            return loc[0], loc[1] + 1</span><br><span class="line">    else:</span><br><span class="line">        return loc</span><br></pre></td></tr></table></figure>
<h4 id="h-n-函数体现："><a href="#h-n-函数体现：" class="headerlink" title="h(n)函数体现："></a><code>h(n)</code>函数体现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def compute_cost(loc):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    计算loc到终点消耗的代价</span><br><span class="line">    :param loc:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return min(abs(loc[0] - des_loc[0]), abs(loc[1] - des_loc[1]))</span><br></pre></td></tr></table></figure>
<h4 id="开始计算"><a href="#开始计算" class="headerlink" title="开始计算"></a>开始计算</h4><p>使用<code>road_list</code>来保存走过的路径，同时用另一个集合保存失败的节点——即此节点附近无可用节点，<strong>死胡同</strong>。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 已经走过的路径list，走过的路</span><br><span class="line">road_list = [start_loc]</span><br><span class="line"># 证实是失败的路径</span><br><span class="line">failed_list = []</span><br><span class="line"></span><br><span class="line"># 没有到达终点就一直循环</span><br><span class="line">while road_list[len(road_list) - 1] != des_loc:</span><br><span class="line">    # 当前点</span><br><span class="line">    cur_loc = road_list[len(road_list) - 1]</span><br><span class="line">    # 当前点四周所有可用点</span><br><span class="line">    valid_loc_data = get_all_valid_loc(cur_loc)</span><br><span class="line">    # 如果可用点里包括已经走过的节点，则移除</span><br><span class="line">    for cl in road_list:</span><br><span class="line">        if cl in valid_loc_data:</span><br><span class="line">            valid_loc_data.remove(cl)</span><br><span class="line">    # 如果可用点集合包括失败的节点，则移除</span><br><span class="line">    for fl in failed_list:</span><br><span class="line">        if fl in valid_loc_data:</span><br><span class="line">            valid_loc_data.remove(fl)</span><br><span class="line">    # 没有可用点，视作失败，放弃该节点。从走过的路集合中移除掉</span><br><span class="line">    if len(valid_loc_data) == 0:</span><br><span class="line">        failed_list.append(road_list.pop())</span><br><span class="line">        continue</span><br><span class="line">    # 用评估函数对可用点集合排序，取末端的值，加入走过的路集合中</span><br><span class="line">    valid_loc_data.sort(key=compute_cost, reverse=True)</span><br><span class="line">    road_list.append(valid_loc_data.pop())</span><br></pre></td></tr></table></figure>
<h4 id="看运行结果"><a href="#看运行结果" class="headerlink" title="看运行结果"></a>看运行结果</h4><p><img src="https://wx4.sinaimg.cn/mw690/a28b91d8gy1ftr4cjal19j21ao090aba.jpg" alt></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>人生苦短，我用<code>Python</code>。代码地址在此<a href="https://github.com/JadynAi/Python_D/blob/master/venv/include/maze/AStarRobot.py" target="_blank" rel="noopener">Maze</a>,喜欢<code>Python</code>的小可爱们可以拿去练练手。<br>在研究迷宫的过程中，发现生成迷宫的算法也是很有意思的，等忙完这段时间再去研究研究。嘻<del>~</del><br><strong>以上</strong></p>

    </div>
</article>
        </main>
        <aside class="aside">
            <div class="close"></div>
            <section class="aside-section">
                
    <h1>Categories</h1>

    <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/音视频/">音视频</a></li></ul>

            </section>
            <section class="aside-section">
                
    <h1>Archives</h1>

    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a></li></ul>


            </section>
            <section class="aside-section tag">
                
    <h1>Tags</h1>

    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Camera2/">Camera2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Canvas动画/">Canvas动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MediaCodeC/">MediaCodeC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/交互体验/">交互体验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术讨论/">技术讨论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/科普向/">科普向</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/视觉设计/">视觉设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/视频/">视频</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/音视频/">音视频</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/音频/">音频</a></li></ul>

            </section>
        </aside>
    </div>
</body>

</html>