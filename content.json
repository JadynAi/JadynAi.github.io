{"pages":[{"title":"404","text":"","path":"404/index.html","date":"04-24","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"04-24","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"04-24","excerpt":""}],"posts":[{"title":"仿ios京东启动页“跳过”效果","text":"天共水，水远与天连天净水平寒月漾，水光月色两相兼 简单展示一下动画效果： 项目地址在此，大家若是喜欢的话，不妨点个赞吧好了，简单阐述一下本次动画的原理： 光的效果使用Paint设置Shader来实现，具体则是LinearGradient水平渐变渲染。光影的平移依赖于LinearGradient的setLocalMatrix，通过Matrix的translate来促使光影移动。 在自定义View的onSizeChanged(int w, int h, int oldw, int oldh)方法内初始化引擎：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); tryInitEngine(w); &#125; private void tryInitEngine(int w) &#123; if (mShadowMatrix == null) &#123; if (w &gt; 0) &#123; //控制阴影的Matrix，通过Matrix的变化来实现闪光的滑过效果 mShadowMatrix = new Matrix(); //因为使用了LinearGradient,所以Paint本身的color将毫无意义，所以colors的起始点的色值必须和本来色值一致 int currentTextColor = getCurrentTextColor(); //渐变色层.x0,y0是起点坐标，x1，y1是终点坐标 mLinearGradient = new LinearGradient(0, 0, 50, 0, new int[] &#123;currentTextColor, Color.GREEN, currentTextColor&#125;, null, Shader.TileMode.CLAMP); //画笔设置Shader getPaint().setShader(mLinearGradient); //使用属性动画作为引擎，数值从-SHADOW变化到TextView本身的宽度。间隔时间未1500ms mValueAnimator = ValueAnimator.ofFloat(-50, w).setDuration(1500); mValueAnimator.setInterpolator(new LinearInterpolator()); mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float value = (float) animation.getAnimatedValue(); //Matrix移动来实现闪光滑动 mShadowMatrix.setTranslate(value, 0); invalidate(); &#125; &#125;); mValueAnimator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationRepeat(Animator animation) &#123; super.onAnimationRepeat(animation); mShadowMatrix.reset(); &#125; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); mShadowMatrix.reset(); &#125; &#125;); mValueAnimator.setRepeatCount(mRepeatCount); &#125; &#125; &#125; 简要说明几个重要变量： mShadowMatrix,用来控制Shader位置的Matrix。 mLinearGradient,实现闪光效果的Shader，水平渐变层。 mValueAnimator，属性动画引擎。 这里面使用了一个LinearGradient线性渐变的着色器。着重说一下它的使用方法。先看一下LinearGradient的构造函数： 1234567891011121314151617 /** Create a shader that draws a linear gradient along a line. @param x0 The x-coordinate for the start of the gradient line @param y0 The y-coordinate for the start of the gradient line @param x1 The x-coordinate for the end of the gradient line @param y1 The y-coordinate for the end of the gradient line @param colors The colors to be distributed along the gradient line @param positions May be null. The relative positions [0..1] of each corresponding color in the colors array. If this is null, the the colors are distributed evenly along the gradient line. @param tile The Shader tiling mode */ public LinearGradient(float x0, float y0, float x1, float y1, int colors[], float positions[], TileMode tile) &#123; ......... ..... ...... &#125; 这其中：x0，y0—-&gt;代表起点的坐标x1，y1—-&gt;代表终点的坐标colors—-&gt;colors表示渲染的颜色，它是一个颜色数组，数组长度必须大于等于2positions—-&gt;positions表示colors数组中几个颜色的相对位置，是一个float类型的数组，该数组的长度必须与colors数组的长度相同。如果这个参数使用null也可以，这时系统会按照梯度线来均匀分配colors数组中的颜色title—-&gt;代表了系统提供的几种渲染模式，这里选用了LinearGradient.TileMode.CLAMP模式，表示重复colors数组里的最后一种颜色直到该View结束的地方 这里我们来做个试验，将colors的最后一个色值改为Color.BLUE 1mLinearGradient = new LinearGradient(0, 0, SHADOW_W, 0, new int[] &#123;currentTextColor, Color.GREEN, Color.BLUE&#125;, OK,看一下试验效果. 可见设置了ClAMP模式后，的确是将colors最后的一个色值覆盖到了未渲染区域 监听属性动画的数值更新，来触发重绘，OnDraw（）方法实现尤为简单。12345678@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Log.d(TAG, &quot;onDraw: &quot; + System.currentTimeMillis()); if (mLinearGradient != null) &#123; mLinearGradient.setLocalMatrix(mShadowMatrix); &#125; &#125; Matrix，改变位置即可实现光芒滑过效果 以上就是本次动画的简要原理阐述，项目地址在这里，个中原理已在注释上写的明明白白。FlickerTextView,大家喜欢的话不妨点个赞吧。基于需求的特殊性，本地动画使用了TextView。其实大可不必拘泥于此，本质上还是对Paint设置Shader的使用而已。","path":"2018/04/30/flickerView/","date":"04-30","excerpt":"","tags":[{"name":"Canvas动画","slug":"Canvas动画","permalink":"https://yoursite.com/tags/Canvas动画/"},{"name":"Android","slug":"Android","permalink":"https://yoursite.com/tags/Android/"}],"preview":"https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/20180430-blog-header-bg.jpg"},{"title":"【闻弦歌】--初识音频","text":"学习的目的在于掌握以及更好地使用，学习的第一步就是认知。在音频学习时，我们首先要认知的就是声音。 声音是什么 声音由震动而生，它本质上是一种机械波。既然是波，就拥有波动传播的性质，例如频率、波长等。 对人而言，“声音”于生理学上的体现为大脑接受到的声音，和物理学定义有偏差。人类的耳朵一般只能听到约在20Hz至20,000 Hz（20kHz）范围内的声音，其上限会随年龄增加而降低，蚊音器【注1】就是利用了这种原理。 声音的采集与存储在了解声音采集以及存储之前，我们首先要认知两个概念。即模拟信号和数字信号。信号数据是可以用来表达任何信息的，例如图像、声音、文字等。对信号数据的了解，有利于我们理解声音采集存储的过程中，到底发生了什么。 模拟信号[ analog signal ], [Wiki百科] 是这样解释的： 模拟信号是在时域上数学形式为连续函数的信号，其主要利用对象的一些物理属性来表达传递信息。理论上来说，它的分辨率是接近无穷大的，信息密度大，不存在量化误差。代表着对自然界物理量的描述表达无限逼近真实。同时它也极其容易受干扰。例子：最开始的大哥大传输的就是模拟信号，所以那时候经常出现噪音，通话质量极差。 数字信号[Digital signal]，Wiki百科 解释如下： 数字信号是离散时间信号（discrete-time signal）的数字化表示。 狭义上来说，数字信号就是从模拟信号获取的。 OK，简要的说明了信号数据属性，概念总是苍白无力的，那么接下来我们用一个实际的例子来阐述以上两个属性的含义。就从麦克风录音——&gt;录音文件为例，在这个过程到底发生了什么转换，能让声音变成可播放文件的呢？ 录音解密对着麦克风录音时，麦克风【拾音设备】作了一轮声电转换，将机械振动信号转为模拟信号【在这里模拟信号的体现为连续电信号】。手机【或者计算机】是无法直接处理或存储模拟信号的，因为它是电信号。所以手机【或者计算机】内部会对模拟信号进行采样收集，转化为数字信号，这个过程称之为A/D，模数转换。在这个过程中，采样模拟的波形和原始波形的误差就是噪音了。当然，一定程度上设备的好坏也决定了噪音的程度。By the way，麦克风的工作原理： 麦克风里有一层薄且敏感的碳膜，声音经过时，会压缩空气导致碳膜挤压发生振动。碳膜下方有一个电极，碳膜振动时会接触电极，接触的长短和频率与声波的振幅和频率有关【注2】。这样就完成了第一轮声电转换。 有了录音，自然接下来就是播放了。接着我们会讲一下手机【或者计算机】是如何播放音频文件的。 音频播放 音响设备播放声音，需要连续的电波将音盆的磁圈振动。这个过程，要是向它输入数字信号，那可不好使。音响设备此时需要计算机对它输入模拟信号【有强弱变化的电流】，这个过程叫做D/A,数模转换。模拟信号和数字信号是不相通的，通过模数转换/数模转换来互通。譬如手机播放一个MP3，必须将这个MP3文件解码成模拟信号才能推动扬声器来振动产生声音。 好比是乐谱和演奏一样：A/D，模数转换就是将音乐写成乐谱。而D/A,数模转换，就是乐师将乐谱演奏出来。 音频学习学什么实际上对于APP应用层开发而言，A/D，模数转换和D/A,数模转换大多数情况下是不用接触的。对于Android平台而言，系统已经封装了相当完善的录音Api。它会直接提供给我们，经过A/D模数变换后的二进制序列 PCM文件 【该文件没有附加的文件头和文件结束标志】。而音频开发都是基于PCM文件的。 PCM文件PCM文件是对声音模拟信号的量化，是没有经过压缩的纯音频数据，只有PCM能直接进行声音处理【譬如变声器】。同理，PCM没有文件描述，所以不会有播放器支持播放PCM文件的音乐，除非已知采样率等信息。PCM作为声音的量化体现，主要有以下几个维度来描述声音： 采样率sampleRate，单位【khz】： 取样频率，每秒钟取得声音样本的次数。此值越高，则声音的还原度越高，同时占用的资源也会更多。 常见的有8khz【电话等使用】、22.05khz【广播】、44.1khz【CD音质】、48khz【数字电视】；常用采样率不会超过48khz 44.1khz是Android平台已知唯一兼容大多数固件的采样率 采样位数，单位【bit】： 每一个采样点的采样值，用来衡量声音波动变化的一个参数，也可以说是声卡的分辨率。数值越大，声音质量越好。 大小常为为4bit、8bit、16bit、32bit 声道数channel： 单声道 Mono 双声道 Stereo 用耳机举例，单声道并不是只有一个耳机喇叭发出声音。而是两个喇叭同时发出这个声道的声音。双声道就是两个耳机喇叭分别播出两个声道的声音。 对Android平台而言，立体声就是双声道。 时间 PCM文件计算大小衡量PCM文件数据单位时间内的容量大小，称之为比特率——即1s时间内的比特（bit）数目。那么，来计算一下一个 44.1khz 16bit 2channel的CD音质的比特率为： 144100*16*2=1411200bps=1411.2kbps 那么一段60s的CD音质的声音大小为：11411.2*60/8=10584KB=10.34MB ok，接下来我们详细介绍一下，以上各个单位的换算详情。 比特率，数据传送速度单位,用来衡量带宽的，每s传输的二进制位数： Mbps 即 Milionbit pro second(百万位每秒)Kbps 即 Kilobit pro second（千位每秒）bps 即 bit pro second（位每秒）最小的单位就是bit，也是采样位数，通常缩写为b。这里要着重注意一下，要和另一个单位B区分开来。另，kbps和bps的换算单位也有争议，有的是1kbps=1024bps，有的则是1kbps=1000bps。我们之前计算的10.34MB，是以1000位基准计算的，参考的是wiki百科。 传输的字节数单位，Byte，通常用B表示： 这个才是通常软件上显示的下载速度，也是存储的硬盘上的字节数体现。MB即百万字节也称兆字节 KB即千字节B即字节,其换算单位为1024，公式为：1MB=1024KB=1024*1024B=1024*1024*8b所以，一般1M的网络带宽指的是：1Mbps。它下载的速度上限为：1Mbps=1000kbps=1000000bps。一秒钟走过了10^6个bit，那么换算为Bytes为： 110^6/8=125000 byte/s=122 KB/s PS：有关1kbps=1024bps和1kbps=1000bps的用法依然是混乱的。作为万国共通的SI单位系「k」「M」等接头辞有着1000乘方的意义，IEEE和IEC等学会标准化团体等也正式地跟随这些的用法。但出于计算机初期软件和硬件设计上的情况，是把1024比特作为1000比特，结果在数据的容量和通信速率等中适用这个规则的人增多，导致了现在这样的混乱状态。在通讯的世界中，由于数据通讯开始之前就遵从SI单位系而使用1000倍，并且调制解调器的通信速率开始时也是使用75bps，300bps，1200bps等非2乘方的值，所以一般认为1kbps=1000bps是妥当的。大致来说，存储器和硬盘等存储容量一般使用「1024」，通信速率使用「1000」,但因为根据状况会有不同，需要充分注意使用的是哪边的意义 PCM文件格式可以直接作声音处理对一个PCM文件而言，以采样频率作为变量，其余属性不变。则采样频率越小，播放出来的声音越粗，速度越慢。采样频率越高，声音越细，速度越快。怎么样，是不是很熟悉呢？这种效果差不多就是变声器的原理了，不过变声器要比这个复杂的更多。 以上 注1：蚊音器，也叫蚊音警报器，是一种通过发出高频声音来制止年轻人集会的一种电器设备。最新的版本于2008年晚些时候上市，其可以设置两种频段。一种是大约17.4kHz[1]，一般只有年轻人可以听到的。另一种为8kHz，能被大多数人听到。其最大的前在输出的声压级为108dB。由于人耳朵的功能会随着年纪变化，因此此种声音只有差不多25岁以下的年轻人才听得到。注2：参考《音视频开发进阶指南》第一张第二节 参考资料： Mbps、Kbps、bps、kb、mb的区别，带宽换算 AD/DA转换、模拟、数字的扫盲贴","path":"2018/04/02/audio_start_learn/","date":"04-02","excerpt":"","tags":[{"name":"科普向","slug":"科普向","permalink":"https://yoursite.com/tags/科普向/"},{"name":"音频","slug":"音频","permalink":"https://yoursite.com/tags/音频/"}],"preview":"https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/20180402-blog-header-bg.jpg"},{"title":"吐血整理！17年下半年面试问题以及解析精华整理","text":"前段时间有一篇面试总结，这里是原文原文,奈何只给了考卷没有答案。最近又处于金三银四，正是跳槽加薪的大好良机啊。便抽了时间将答案整理了一下。本文章大部分内容整理自网络，Po出来的网页也是经过了一轮筛选的，可读性比较好一点。另，一些主观性比较强的问题就添加了一丢丢个人看法，大家尽兴阅读。 本文系个人辛苦整理收纳，转载请注明出处。 2017Android面试总结之答案篇 LRUCache原理 LruCache中维护了一个集合LinkedHashMap，该LinkedHashMap是以访问顺序（accessOrder为true，其余非构造函数此值全为false）排序的。当调用put()方法时，就会在集合中添加元素，并调用trimToSize()判断缓存是否已满，如果满了就用LinkedHashMap的迭代器删除队尾元素，即近期最少访问的元素。当调用get()方法访问缓存对象时，就会调用LinkedHashMap的get()方法获得对应集合元素，同时会更新该元素到队头。 LinkedHashMap内部是使用双向循环链表来存储数据的。也就是每一个元素都持有他上一个元素的地址和下一个元素的地址。 图片加载原理（Glide） 这篇文章对几大开源图片加载库做了对比Android 三大图片缓存原理、特性对比 个人使用过ImageLoader和Glide，相对而言对Glide较为熟悉。对Glide这个点可以稍作分析，如何感知activity或者Fragment生命周期的： 往Activity或者Fragment内部添加一个SupportRequestManagerFragment透明的Fragment，用回调的方式感知生命周期。 模块化的好处 模块化的好处以及原因 JVM JVM的工作原理 总结的JVM面试题 视频加密传输 加密： DES对整个视频文件进行加密，但耗时较长。 将视频数据流前n个字节（n&gt;=2）打乱即可达到加密目的，使用到了内存映射文件（对RandomAccessFile和MappedByteBuffer的使用）。参考这篇文章 数据加密传输： android上数据加密传输比较麻烦，得不偿失。综合阅读过的几篇文章，觉得还是先加密再传输来得好。 统计启动时长，标准 参考文章 app冷启动的流程如下：12345678910-&gt; Application 构造函数-&gt; Application.attachBaseContext()-&gt; Application.onCreate()-&gt; Activity 构造函数-&gt; Activity.setTheme()-&gt; Activity.onCreate()-&gt; Activity.onStart-&gt; Activity.onResume-&gt; Activity.onAttachedToWindow-&gt; Activity.onWindowFocusChanged 如何保持应用的稳定性 经验之谈：性能分析，内存监测，Monkey ThreadLocal 用处：针对线程操作对象，其余线程不能进行操作 原理：ThreadLocal的操作都是针对当前线程持有的一个ThreadLocalMap对象，其内部维护了一个Entry[]（弱引用）数组。所以不同线程操作同一个ThreadLocal对象，内部说白了都是操作各个线程自己的ThreadLocalMap对象而已。 谈谈classloader 主观性比较强，谈一下自己了解的即可。可参考classloader使用与原理分析 动态布局 代码写布局，无他唯手熟尔 一篇干货分享一下 热修复，插件化 主观性较强，视个人了解程度而区分。参考 HashMap源码，SparseArray原理 HashMap实现原理 简洁对比HashMap和SparseArray 应用启动优化 参考Android性能优化 视觉优化，启动界面设置为特殊样式 异步初始化组件； 梳理业务逻辑，延迟初始化组件、操作； 正确使用线程； 去掉无用代码、重复逻辑等； 怎么去除重复代码 抽取成方法，抽取成对象，抽取成Module； 不要过度设计，及时重构，代码要经常回顾； SP是进程同步的吗?有什么方法做到同步 能同步但不建议使用，使用ContentProvider可以做到同步。ContentProvider多进程共享SP数据 SurfaceView介绍 View适用于主动更新的情况，而SurfaceView则适用于被动更新的情况，比如频繁刷新界面。 View在主线程中对页面进行刷新，而SurfaceView则开启一个子线程来对页面进行刷新。 View在绘图时没有实现双缓冲机制，SurfaceView在底层机制中就实现了双缓冲机制 HashMap实现原理，ConcurrentHashMap 的实现原理 参考此篇文章 BroadcastReceiver，LocalBroadcastReceiver 区别 应用场景 BroadcastReceiver用于应用之间的传递消息； 而LocalBroadcastManager用于应用内部传递消息，比broadcastReceiver更加高效 安全 BroadcastReceiver使用的Content API，所以本质上它是跨应用的，所以在使用它时必须要考虑到不要被别的应用滥用 LocalBroadcastManager不需要考虑安全问题，因为它只在应用内部有效 Bundle、Handler、事件传递机制，都是基础 线程间操作List App启动流程，从点击桌面开始 这一篇文章总结的好一点，App启动流程 动态加载（插件化技术） 主观性较强，视个人经历的项目而定。个人觉得如果简单介绍的话，这篇文章会好一点。清晰简洁动态加载简单易懂的介绍方式 GC回收机制 新生代和旧生代采用不同的垃圾回收机制 可参考Java垃圾回收机制 画出Android大体架构图 经典图 点击 Android Studio 的 build 按钮后发生了什么 Android使用gradle构建生成的apk关键就是aapt处理资源文件，aidl处理.aidl，javac生成.class文件，proguard混淆后再由dex生成.dex文件，由apkbuilder签名后再经zipalign对齐字节码就可以上线发布了 这篇文章分析的较为详细，AS的build做了什么 一个应用程序安装到手机上时发生了什么 安装和卸载都是通过PackageManager，实质上是实现了PackageManager的远程服务PackageManagerService来完成具体的操作，所有细节和逻辑均可以在PackageManagerService中跟踪查看； 所有安装方式殊途同归，最终就回到PackageManagerService中，然后调用底层本地代码的installd来完成。再看apk的安装过程。 拷贝apk文件到指定目录 解压apk，拷贝文件，创建应用的数据目录 解析apk的AndroidManifinest.xml文件 向Launcher应用申请添加创建快捷方式 深入探究apk安装过程 对 Dalvik、ART 虚拟机有基本的了解 Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码 可参考这篇文章JAVA虚拟机、Dalvik虚拟机和ART虚拟机简要对比 Android 上的 Inter-Process-Communication 跨进程通信时如何工作的 跨进程通信主要靠Binder详解Binder Android中App 是如何沙箱化的,为何要这么做 Android中的沙箱化可以提升系统安全性和效率 权限管理系统 Android权限机制 进程以及Application生命周期 进程生命周期 有关Application Recyclerview和ListView对比 相信目前大部分Android开发已经舍弃了ListView而转向Recyclerview的怀抱了吧，无需赘言。 快速排序以及B+树，算法算是我比较薄弱的环节，不敢多言 TCP和UDP的区别 TCP是面向连接的协议，提供稳定的双向通信功能，本身提供超时重连机制。UDP是无连接的，提供不稳定的单向通信功能 synchronized与Lock的区别 从用法、性能、用途来分析，很不错。深入研究 Java Synchronize 和 Lock 的区别与用法 volatile 排他锁，保证了所有线程看到的变量都是一致的 Java线程池 java对象生命周期 经典图例 双亲委派模型 老油条式面试题，这篇文章有一个比较新颖的疑问解答关于Java类加载双亲委派机制的思考（附一道面试题） Android事件分发机制 基础的基础 MVP模式 组件和业务逻辑相互分离，两不相知。Google提供的Demo里，View层级真是纯是view操作，包括Listener的一部分都由Presenter承担了。 接口定义清晰明朗 视个人项目经历而谈，详细了解就仔细说，不太懂就说个大概 RxJava 开发神器，错误处理、线程调度、写出来的代码优雅。 可从线程调度以及源码角度剖析剖析。 抽象类和接口的区别 属性和行为的区别 Android消息机制 进程调度 进程与线程 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 死锁 老问题，Java 实例 - 死锁及解决方法 进程状态 图 JVM内存模型 Java 常用并发集合有哪些 非阻塞式列表对应的实现类：ConcurrentLinkedDeque 阻塞式列表对应的实现类：LinkedBlockingDeque 用于数据生成或者消费的阻塞式列表对应的实现类：LinkedTransferQueue 按优先级排序列表元素的阻塞式列表对应的实现类：PriorityBlockingQueue 带有延迟列表元素的阻塞式列表对应的实现类：DelayQueue 非阻塞式列表可遍历映射对应的饿实现类：ConcurrentSkipListMap 随机数字对应的实现类：ThreadLockRandom 原子变量对应的实现类：AtomicLong和AtomicIntegerArray ConcurrentHashMap 的实现原理 Java线程run和start方式的区别 常见的数据结构 如图 堆排序实现 链表反转 synchronized用法 写的较为详细，最后的总结面试时可以直接拿来用Java中Synchronized的用法 OkHttp是如何处理缓存的 OkHttp缓存处理 OkHttp还是使用的Http缓存，需要后台配合。当然也可以单纯的在客户端作拦截处理 bitmap如何处理大图，如何预防OOM 老生常谈的问题，彻底了解 bitmap 高效加载 进程保活 黑科技保活 listview图片加载错乱的原理和解决方案 郭霖大神的解析，拳拳到肉ListView异步加载图片乱序问题，原因分析及解决方案 广播小结 service生命周期 多线程 用RxJava的话会方便很多。RxJava中的多线程，这篇文章真的太赞了 AsyncTask 缺陷，一部分是使用不当，一部分是其本身存在的缺陷。网上的大部分文章都是看了一遍其实都是使用的问题，推荐看看这篇详细解读AsyncTask的黑暗面以及一种替代方案【By，AsyncTask真的很难用，因为要注意的地方太多了😒】 数据库数据迁移，把大象装进新冰箱共分几步？ 将表名改成临时表ALTER TABLE Order RENAME TO _Order 创建新表CREATETABLE Test(Id VARCHAR(32) PRIMARY KEY ,CustomName VARCHAR(32) NOTNULL , Country VARCHAR(16) NOTNULL) 导入数据INSERTINTO Order SELECT id, “”, Age FROM _Order 删除临时表DROPTABLE _Order 设计模式 自由发挥题目。但亦有文章可以参考，这是一个有关Android中常见设计模式解析的一个专栏，推荐指数五颗星Android常见设计模式 Java注解 EventBus、Retrofit等都用到了注解。是一个很强大的东西，关键是代码写起来敲好看。深入理解Java注解类型(@Annotation) Android优化 自由度很高的问题，随意发挥。参考这个优化系列的文章Android 性能优化的方方面面 EventBus实现原理 相比起来，还是更喜欢RxJava自己实现一套Rxbus。EventBus 3.0 源码分析","path":"2018/03/10/2018_face_book/","date":"03-10","excerpt":"","tags":[{"name":"Android","slug":"Android","permalink":"https://yoursite.com/tags/Android/"},{"name":"开发经验","slug":"开发经验","permalink":"https://yoursite.com/tags/开发经验/"}],"preview":"https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/post-bg-2015.jpg"},{"title":"文字动次打次，让文字动态绘制出来","text":"本文属于Android技术论述文章，阅读完大致需要五分钟 原创文章，转载请注明出处。 没时间的小伙伴可以直接跳过文章，点击项目地址，如果喜欢的话，顺手给个star那是极好的【娇羞……】 二话不说，效果奉上！ 知识点序列： Canvas绘制 TextPaint Path PathMeasure【测量Path】 代码分析获取文字的轮廓Path在TextPaint中有这样一个方法，getTextPath,如下： 12345678public void getTextPath(String text, int start, int end, float x, float y, Path path) &#123; if ((start | end | (end - start) | (text.length() - end)) &lt; 0) &#123; throw new IndexOutOfBoundsException(); &#125; nGetTextPath(mNativePaint, mNativeTypeface, mBidiFlags, text, start, end, x, y, path.mutateNI()); &#125; 👀其中nGetTextPath里面是调用了一个原生函数，具体实现不必理会。只需要了解函数的各个参数就可以了。 参数含义： text：文本内容 start：需要测量的文本中的第一个字符的下标 end：需要测量的文本最后一个字符的下标加1 x：Path起点的坐标X y：Path起点的坐标Y path：最终测量得到的Path Path分段绘制PathMeasure这个类可以说是Path相关的工具解析类，里面大多是原生函数，实现细节不必深究。只需要会使用方法即可。第一步我们得到文字的轮廓Path之后，这一步将此path按段绘制出来即可。在代码中，由CanvasView这个类来具体实现绘制的详尽流程。看代码，将文本轮廓Path设置进来： 123456789101112131415161718// 保留一份原始Path，用作绘制最终填色的文字 mOrignalPath = orignalPath; if (null == mPathMeasure) &#123; mPathMeasure = new PathMeasure(); &#125; //先重置一下需要显示动画的path mAnimPath.reset(); mAnimPath.moveTo(0, 0); mPathMeasure.setPath(orignalPath, false); // getLength（）方法获得的是当前path的长度；而nextContour（）方法是将Path切换到下一段Path，多应用在复杂path中 mTextCount = 0; // 计算文字总共有多少段Path while (mPathMeasure.nextContour()) &#123; mTextCount++; &#125; // PathMeasure重新设置一次 mPathMeasure.setPath(orignalPath, false); mPaint.setStyle(Paint.Style.STROKE); 其中成员变量mAnimPath，即是用在onDraw()方法内用于绘制的Path。我们会不停地通过PathMeasure刷新这个Path，用于动画流畅运行。 接下来是引擎代码，使用的是属性动画，看代码实现： 1234567891011121314151617181920212223242526272829if (null == mValueAnimator) &#123; // 如果一个文本Path包含n个小Path，那么属性动画会Repeat运行n次，每一段小path默认动画时间为900ms mValueAnimator = ValueAnimator.ofFloat(0.0f, 1.0f); mValueAnimator.setDuration(900); mValueAnimator.setInterpolator(new LinearInterpolator()); &#125; // 引擎无限次重复发动 mValueAnimator.setRepeatCount(ValueAnimator.INFINITE); mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float value = (float) animation.getAnimatedValue(); // 将一段小Path从0%到100%赋值到mAnimPath中，调用重绘 mPathMeasure.getSegment(0, mPathMeasure.getLength() * value, mAnimPath, true); invalidate(); &#125; &#125;); mValueAnimator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationRepeat(Animator animation) &#123; super.onAnimationRepeat(animation); //绘制完一条Path之后，再绘制下一条，直到完成为止。 if (!mPathMeasure.nextContour()) &#123; animation.end(); &#125; invalidate(); &#125; &#125;); 注释里具体原因亦已写明。这种引擎的设置，就是每一小段Path不管长短，其绘制时间都是相等的，会造成动画看起来时慢时快。 其实要让动画一直匀速跑起来也很容易，就是提前将原始Path测量一遍，设置一个总时间，然后根据小Path的长短来按照比例分配时间。这样即可使动画匀速进行。具体代码不再多言😘，有兴趣的小伙伴可以试试。 再看看CanvasView内的onDraw()方法实现： 12345678910@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (null != mPathMeasure &amp;&amp; mPathMeasure.getLength() == 0) &#123; mPaint.setStyle(Paint.Style.FILL); canvas.drawPath(mOrignalPath, mPaint); return; &#125; canvas.drawPath(mAnimPath, mPaint); &#125; 这里面的代码更加简单，在Path绘制完之前，一直绘制mAnimPath即可。Path绘制完之后，设置画笔的绘制风格，将文字空白处填上色即可。 以上。就是本次项目的主要思路解析。大家走过路过不要错过，给添个Star呗😄。","path":"2017/11/02/anim_text/","date":"11-02","excerpt":"","tags":[{"name":"Canvas动画","slug":"Canvas动画","permalink":"https://yoursite.com/tags/Canvas动画/"},{"name":"Android","slug":"Android","permalink":"https://yoursite.com/tags/Android/"}],"preview":"https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/20170819-blog-header-bg.jpg"},{"title":"实现薄荷Loading动画","text":"本文属于Android技术论述文章，阅读完大致需要五分钟 原创文章，转载请注明出处。 没时间的小伙伴可以直接跳过文章，点击项目地址，如果喜欢的话，顺手给个star那是极好的【娇羞……】 好吧。先说一下为什么要做这个项目。前几天使用薄荷的时候，凑巧看到了这个Loading动画，觉得效果还不错。就想尝试着实现一下。先看一下原版的效果，GIF录制的比较快，但应该还可以看清楚。 先上本次最终实现的效果图吧，颜色当然选择今年最流行的原谅色： 思路分析 1、整个图形的形状如何绘制 2、如何让线条动起来 整个图形的形状分析 好了，首先我们来分析一下这个图案，如果是静态的，那么如何绘制？很简单，拆分。我们将图形拆开分解，然后再看。分析细节和步骤，这是要点。我这里将这个图分成了三份。 第一个，也就是叶柄。也就是下面那一条小小的竖线。原Loading图中不甚明显，但还是有的。叶柄没什么说的，直线就可以了。 第二个，叶子的左轮廓边缘和右轮廓边缘。这是一段下肥上窄的弧线，椭圆截取感觉不妥，我这里采用的是贝塞尔二阶曲线。有关Android贝塞尔相关的知识大家可以看看这篇文章。 第三个，也就是叶片的脉络，线和线交叉连接，没什么可说的。 那么重点其实就是叶子左右轮廓的绘制了，我画了一张草图。大家可以看看： 其中黑色的框作为View的边界。A点是左轮廓曲线的起点，B点事贝塞尔曲线的控制点，我把它定义到了View的左边框那里。C点事整个贝塞尔曲线的终点，D点则是实际上曲线的最高点。右轮廓则和左轮廓是镜像存在。图有点潦草，不过应该还看得懂。 好了，静态图形拆解完毕。接着看，如何让图动起来。 如何让线条动起来整个项目中，如何让线条真正的动起来才是要点。刚开始在这里的思路，是想使用canvas.drawCircle绘制在一张Bitmap上，以点汇面。后面实现起来发现，这种方式特别不靠谱。为什么不靠谱呢？因为点连接成线，每次移动的速率和距离都得计算，很麻烦。很容易出现断点的情况。最后，我采用的是让canvas去绘制一段Path路径，然后Path路径不停的刷新改变。这样做的好处，是Path更加直观易于控制。而且还不用多绘制一张Bitmap。整个项目中，自定义的View，LeafAnimView做的工作很少，只是在onDraw方法内，调起了绘制而已。具体的绘制都交给LeafAtom了。面向对象嘛。 具体的思路，是我把总时间按比例分成四部分。生成四个属性动画，在属性动画的监听里作Path的x和y的变化。在绘制的时候，只需要将这四个动画依次播放，即可得到每个时间段的具体运动值。而且还是均匀变化的。 LeafAnimView内部作为动画引擎的是一个ValueAnimator,使用它来触发View的onDraw。同时也使用它来控制整个动画的时间。 123456789mValueAnimator = ValueAnimator.ofFloat(0, 1); mValueAnimator.setDuration(5000); mValueAnimator.setRepeatCount(ValueAnimator.INFINITE); mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; invalidate(); &#125; &#125;); LeafAtom类内部接受到这个总时长，然后将运动总时间分割，根据比例计算出绘制叶柄、左右轮廓、脉络的动画时间。 123456789101112131415161718192021222324252627282930313233343536-------在LeafAnimView类内部--------- @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (null == mLeafAtom) &#123; //传入总时长 mLeafAtom = new LeafAtom(getWidth(), getHeight(), mValueAnimator.getDuration()); &#125; if (!mValueAnimator.isStarted()) &#123; mValueAnimator.start(); &#125; //开始绘制 mLeafAtom.drawGraph(canvas, mPaint); &#125; -------在LeafAtome类---------------public static final float PETIOLE_RATIO = 0.1f;//叶柄所占比例public LeafAtom(int width, int height, long duration) &#123; mWidth = width; mHeight = height; mPetioleTime = (long) (duration * PETIOLE_RATIO);//绘制叶柄的时间 mArcTime = (long) (duration * (1 - PETIOLE_RATIO) * 0.4f);//左右轮廓弧线的时间 mLastLineTime = duration - mPetioleTime - mArcTime * 2;//最后一段叶脉的时间 mBezierBottom = new PointF(mWidth * 0.5f, mHeight * (1 - PETIOLE_RATIO));//左侧轮廓底部点 mBezierControl = new PointF(0, mHeight * (1 - 3 * PETIOLE_RATIO));//左侧轮廓控制点 mBezierTop = new PointF(mWidth * 0.5f, 0);//左侧轮廓顶部结束点 mVeinBottomY = mHeight * (1 - PETIOLE_RATIO) - 10;//右侧轮廓底部点Y轴坐标，稍稍低一点 mOneNodeY = mVeinBottomY * 4 / 5;//第一个节点的Y轴坐标 mTwoNodeY = mVeinBottomY * 2 / 5;//第二个节点Y轴坐标 initEngine(); setOrginalStatus(); &#125; 在LeafAtom的构造函数中，得到每一个阶段动画的时间，然后生成四个属性动画，在这个属性动画的监听里去做Path的x和y坐标的值变化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 初始化path引擎 */ private void initEngine() &#123; //叶柄动画，Y轴变化由底部运动到叶柄高度的地方 mPetioleAnim = ValueAnimator.ofFloat(mHeight, mHeight * (1 - PETIOLE_RATIO)).setDuration(mPetioleTime); //左右轮廓贝塞尔曲线，只需要只奥时间变化是从0~1的。起点、控制点、结束点都知道了 mArcAnim = ValueAnimator.ofFloat(0, 1.0f).setDuration(mArcTime); //绘制叶脉的动画 mLastAnim = ValueAnimator.ofFloat(mVeinBottomY, 0).setDuration(mLastLineTime); mPetioleAnim.setInterpolator(new LinearInterpolator()); mArcAnim.setInterpolator(new LinearInterpolator()); mLastAnim.setInterpolator(new LinearInterpolator()); mArcRightAnim = mArcAnim.clone(); mPetioleAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mY = (float) animation.getAnimatedValue(); &#125; &#125;); mArcAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; computeArcPointF(animation, true); &#125; &#125;); mArcRightAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; computeArcPointF(animation, false); &#125; &#125;); mLastAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mY = (float) animation.getAnimatedValue(); float tan = (float) Math.tan(Math.toRadians(30)); if (mY &lt;= mOneNodeY &amp;&amp; mY &gt; mTwoNodeY) &#123; mOneLpath.moveTo(mX, mOneNodeY); mOneRpath.moveTo(mX, mOneNodeY); //这里的参数x和y代表相对当前位置偏移量，y轴不加偏移量会空一截出来，这里的15是经验值 mMainPath.addPath(mOneLpath, 0, EXPRIENCE_OFFSET); mMainPath.addPath(mOneRpath, 0, EXPRIENCE_OFFSET); //第一个节点和第二个节点之间 float gapY = mOneNodeY - mY; mOneLpath.rLineTo(-gapY * tan, -gapY); mOneRpath.lineTo(mX + gapY * tan, mY); &#125; else if (mY &lt;= mTwoNodeY) &#123; mTwoLpath.moveTo(mX, mTwoNodeY); mTwoRpath.moveTo(mX, mTwoNodeY); //第二个节点，为避免线超出叶子，取此时差值的一半作计算 float gapY = (mTwoNodeY - mY) * 0.5f; mMainPath.addPath(mTwoLpath, 0, EXPRIENCE_OFFSET); mMainPath.addPath(mTwoRpath, 0, EXPRIENCE_OFFSET); mTwoLpath.rLineTo(-gapY * tan, -gapY); mTwoRpath.rLineTo(gapY * tan, -gapY); &#125; &#125; &#125;); mEngine = new AnimatorSet(); mEngine.playSequentially(mPetioleAnim, mArcAnim, mArcRightAnim, mLastAnim); mEngine.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); setOrginalStatus(); &#125; &#125;); &#125; 计算贝塞尔曲线运动过程中的方法。贝塞尔曲线是有一个函数的，我们知道起点、控制点、终点的话，就可以根据时间计算出此时此刻的x和y的坐标。而这个时间变化是从0~1变化的。谨记。 1234567891011121314151617private void computeArcPointF(ValueAnimator animation, boolean isLeft) &#123; float ratio = (float) animation.getAnimatedValue(); //ratio从0~1变化，左右轮廓三个点不一样 PointF bezierStart = isLeft ? mBezierBottom : mBezierTop; PointF bezierControl = isLeft ? mBezierControl : new PointF(mWidth, mHeight * (1 - 3 * PETIOLE_RATIO)); PointF bezierEnd = isLeft ? mBezierTop : new PointF(mWidth * 0.5f, mVeinBottomY); PointF pointF = calculateCurPoint(ratio, bezierStart, bezierControl, bezierEnd); mX = pointF.x; mY = pointF.y; &#125; private PointF calculateCurPoint(float t, PointF p0, PointF p1, PointF p2) &#123; PointF point = new PointF(); float temp = 1 - t; point.x = temp * temp * p0.x + 2 * t * temp * p1.x + t * t * p2.x; point.y = temp * temp * p0.y + 2 * t * temp * p1.y + t * t * p2.y; return point; &#125; 叶脉的绘制，在节点一和节点二，分别加上两个向左和向右伸展开的Path路径即可。 需要说明的是，lineTo和rLineTo的区别，lineTo的参数代表的就是目标参数，而rLineTo的参数代表的是，目标参数和起点参数的差值。 最后在drawGraph函数中，启动这个动画集合： 12345678public void drawGraph(Canvas canvas, Paint paint) &#123; if (mEngine.isStarted()) &#123; canvas.drawPath(mMainPath, paint); mMainPath.lineTo(mX, mY); &#125; else &#123; mEngine.start(); &#125; &#125; 以上，就是本次项目的主要思路了。相关注释代码里都写的很清楚了，项目地址在这里。仿薄荷Loading动画，大家走过路过千万别忘了给个Star啊。","path":"2017/08/19/bohe_path/","date":"08-19","excerpt":"","tags":[{"name":"Canvas动画","slug":"Canvas动画","permalink":"https://yoursite.com/tags/Canvas动画/"},{"name":"Android","slug":"Android","permalink":"https://yoursite.com/tags/Android/"}],"preview":"https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/20170819-blog-header-bg.jpg"},{"title":"实用性MAX!像普通View一样自由使用的粒子组件","text":"原创文章，转载请注明出处。之前作过一篇萤火虫飞舞粒子效果，当时看还不错。无论是性能还是UI都满足了当时的设计效果，但实际应用到项目中，却发现由于SurfaceView其本身是绘制在window层面上的，对View本身的属性有很多的限制，用起来却不是很实在，还存在着很多不足。 于是便将之前的效果重新写了一下，改用继承View来实现，虽然说和SurfaceView相比，在绘制性能上有那么一丝丝的不足 。但轮子本质的含义还是为了服务于项目，项目中方便的使用才是最重要的。 阅读本文，大概需要三分半钟。如果需要直观看代码的话请点这里点这里！！首先看一下效果图 接着分析实现过程中的几个问题 如何保持不间断的绘制 粒子的运动轨迹控制（随机方向，碰到边界回弹以及旋转） 问题1：如何保持不间断的绘制​ View 的粒子绘制本身实在onDraw中进行的，所以最开始我的方案是在canvas绘制完一波之后，继续调用 invalidate()方法，这样就形成了一个死循环，就达到了不间断重复绘制的效果。 1234567891011@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(); //粒子的一波绘制 for (Particle circle : mCircles) &#123; circle.drawItem(canvas); &#125; canvas.restore(); invalidate();&#125; 这里需要注意的是，canvas的绘制是一个阻塞的过程，也就是从canvas.save()方法之后，一直到invalidate()之前，是阻塞的。 重绘是会一直等到所有的粒子绘制完成之后，才会继续调起的。 Tips： canvas的save和restore方法是搭配使用的。save存储之前的canvas状态，restore恢复save之前的状态。 save方法是可以多次使用的，可以搭配使用的是方法restoreToCount(saveCount)。参数saveCount从1开始计数，表示可以恢复到第几次save之前的状态。 ​ 这种方式的缺点在demo完成之后很明显的体现了出来。第一，速度不可控制，譬如有些时候恰恰需要粒子变慢一点呢。使用这种方式就不太好实现了。第二，粒子动画的播放和暂停实现起来不优雅，诚然写一个布尔值来控制也可以，但也难免………………太不优雅了吧。反正我个人是比较不喜欢写这种代码的。 ​ 那么，最终我的实现方式，是采用了属性动画来实现的，没错——就是ValueAnimator。来看代码： 123456789101112private ValueAnimator mParticleAnim;-----------------mParticleAnim = ValueAnimator.ofInt(0).setDuration(30);mParticleAnim.setRepeatCount(ValueAnimator.INFINITE);mParticleAnim.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationRepeat(Animator animation) &#123; super.onAnimationRepeat(animation); Log.d(TAG, &quot;onAnimationRepeat: &quot; + System.currentTimeMillis()); invalidate(); &#125;&#125;); 这段代码展示出来，你懂得。 在一个无限循环的属性动画里，在Repeat监听事件里，调用View的invalidate方法重绘。这样每次触发重绘的时间间隔就是属性动画的持续时间。 要是想控制粒子的运动速率，那么只需要调整动画的持续时间即可。 而且如果要对外暴露粒子动画开始或者停止的方法，只需要控制属性动画的start和stop就行了。 问题2：粒子的运动轨迹​ 在构建轮子的时候，思路其实一直都很清晰。View层级主要是调起和控制绘制。具体要绘制什么东西和路线的控制都由粒子对象内部来实现。这样就可以贯彻单一原则，各自负责各自的东西，降低耦合性。 ​ 我们来看一下粒子对象Particle内的代码： 1234567891011121314151617181920212223242526272829303132333435public Particle(Bitmap drawBitmap, Matrix matrix, Paint paint, float x, float y, int width, int height) &#123; //绘制的bitmap对象和矩阵对象，矩阵用来控制旋转和运动方向 mDrawBitmap = drawBitmap; mBitmapMatrix = matrix; mDrawBitmapWidth = drawBitmap.getWidth(); mDrawBitmapHeight = drawBitmap.getHeight(); mBitmapCenterX = mDrawBitmapWidth / 2f; mBitmapCenterY = mDrawBitmapHeight / 2f; //画笔对象 mPaint = paint; //view 的宽和高用来判断边界 this.mWidth = width; this.mHeight = height; //粒子运动的坐标 this.mX = x; this.mY = y; //粒子的开始坐标 mStartX = x; mStartY = y; //x 和y轴的运动方向选择，随机函数 mIsAddX = mRandom.nextBoolean(); mIsAddY = mRandom.nextBoolean(); setRandomParm();&#125;private void setRandomParm() &#123; //x 和 y轴每次运动的距离和每次旋转的角度，随机值 mDisX = mRandom.nextInt(2) + 1.2f; mDisY = mRandom.nextInt(2) + 1.2f; mAddDegree = mRandom.nextInt(5) + 3f;&#125; ​ 运动轨迹这方面只需要随机出来x和y轴的方向，还有每次递增或者递减的值即可。怎么样是不是丝毫没有技术难度啊。好了，看绘制和到边界的处理代码吧。 123456789101112131415161718192021222324252627282930313233343536public void drawItem(Canvas canvas) &#123; //绘制 mBitmapMatrix.reset(); mBitmapMatrix.preTranslate(mX += getPNValue(mIsAddX, mDisX), mY += getPNValue(mIsAddY, mDisY)); mBitmapMatrix.preRotate(mDegrees += mAddDegree, mBitmapCenterX, mBitmapCenterY); canvas.drawBitmap(mDrawBitmap, mBitmapMatrix, mPaint); Log.d(TAG, &quot;mX : &quot; + mX); Log.d(TAG, &quot;mY : &quot; + mY); judgeOutline();&#125;private void judgeOutline() &#123; boolean judgeX = mX &lt;= 0 || mX &gt;= (mWidth - mDrawBitmapWidth); boolean judgeY = mY &lt;= 0 || mY &gt;= (mHeight - mDrawBitmapHeight); if (judgeX) &#123; mIsAddX = !mIsAddX; mIsAddY = mRandom.nextBoolean(); setRandomParm(); if (mX &lt;= 0) &#123; mX = 0; &#125; else &#123; mX = mWidth - mDrawBitmapWidth; &#125; return; &#125; if (judgeY) &#123; mIsAddY = !mIsAddY; mIsAddX = mRandom.nextBoolean(); setRandomParm(); if (mY &lt;= 0) &#123; mY = 0; &#125; else &#123; mY = mHeight - mDrawBitmapHeight; &#125; &#125;&#125; ​ 以上就是粒子对象内部的运动轨迹和边界判断代码了，怎样，是不是超级简单呢？ ​ 好了，如果你喜欢我的文章的话，那么请不要犹豫，给我一个star吧。GitHub地址：这里这里！！","path":"2017/06/28/android_partical/","date":"06-28","excerpt":"","tags":[{"name":"Canvas动画","slug":"Canvas动画","permalink":"https://yoursite.com/tags/Canvas动画/"},{"name":"Android","slug":"Android","permalink":"https://yoursite.com/tags/Android/"}],"preview":"https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/20170628-blog-header-bg.jpg"},{"title":"低消耗、带回滚动画的仿探探交互效果","text":"原创文章，转载请注明出处。 前段时间项目中有一个仿探探的交互界面，写代码的过程中，觉得效果还不错。就把思路和原理记录了下来，分享一下。 先奉上GitHub地址，大家感兴趣可以来个starInfinateCard 套路还是要走一下的，先给大家看一下效果图: 真机上一点都不卡！一点都不卡！不卡！！！ 又学习了一些录制GIF的方法，这次来一张真机的效果！！ 会用到的知识点 Recyclerview的layoutManager实现布局 使用ItemTouchHelper处理滑动事件 手指滑动过程中，view的UI渐变（透明度或者其它） RecyclerView的ItemAnimator实现回滚动画 1、LayoutManger众所周知，Recyclerview之所以强大，完全在于它百变的适应性。它能实现任何你想要的布局样式，而它的奥秘就在于LayoutManger。 ​ 本次项目中我们UI效果仿照探探的样式，是卡牌样式的堆叠效果，按照List集合的顺序沿着Z轴纵向深处排列。这里有一个值得注意的Tip，子view是按照list集合的顺序去绘制的，也就是在这个我们自定义的LayoutManger里，第二个view会覆盖第一个，第三个会覆盖第二个，以此类推。如果我们想要第一眼就看到List集合的第一个，那么必须将list集合reverse后，再来绘制。 ​ 好了，我们来看代码。LayoutManger的精髓其实就在于onLayoutChildren（……）这个方法，通过这个方法来实现自定义的布局。 12345678910111213141516171819@Overridepublic void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; int itemCount = getItemCount(); // 代码的稳健之道，就在于该保护的地方一定要保护 if (itemCount == 0) &#123; return; &#125; detachAndScrapAttachedViews(recycler); for (int position = 0; position &lt; itemCount; position++) &#123; View view = recycler.getViewForPosition(position); addView(view); measureChildWithMargins(view, 0, 0); int widthSpace = getWidth() - getDecoratedMeasuredWidth(view); int heightSpace = getHeight() - getDecoratedMeasuredHeight(view); // recyclerview 布局 layoutDecoratedWithMargins(view, widthSpace / 2, heightSpace / 2, widthSpace / 2 + getDecoratedMeasuredWidth(view), heightSpace / 2 + getDecoratedMeasuredHeight(view)); &#125; ​ 很多人看到这里，肯定会喷出一句“卧槽！这就完了，就这点代码？” ​ 没错，如果不追求精细的话，这点代码确实可以搞定这个布局样式。现在我们来逐行分析一下代码。 detachAndScrapAttachedViews(recycler)这个方法就是将所有的view缓存在scrap里。Recyclerview有二级缓存，scrap和Recycle。使用Detach方式处理的view缓存在scrap里，用的时候不需要重新绑定数据。Remove方式处理的view缓存在Recycle里，使用的时候会重新绑定数据。 接下来的for循环代码就简单的多了，无非就是获得view的宽高信息，将其布局在Recyclerview内 当然，如果只是以上那些简单的代码，未免也太对不起Recyclerview了。毕竟Recyclerview最强大的地方就是对view的回收和利用了，要不然为什么叫Recycler呢。 对子view的回收利用​ 首先这种卡牌叠层的交互模式，不需要展示那么多的view，也就是我们仅仅需要让前几个view展示出来就可以了。其他的view，放在scrap缓存里即可。 12345678910111213141516171819202122232425262728293031@Overridepublic void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; int itemCount = getItemCount(); // 代码的稳健之道，就在于该保护的地方一定要保护 if (itemCount == 0) &#123; return; &#125; detachAndScrapAttachedViews(recycler); // 测量子view的位置信息并储存 for (int position = 0; position &lt; itemCount; position++) &#123; // 根据position获取一个碎片view，可以从回收的view中获取，也可能新构造一个 View view = recycler.getViewForPosition(position); Log.d(TAG, &quot;recycler&quot; + view.getTag().toString()); addView(view); if (mViewInfo == null) &#123; // 计算此碎片view包含边距的尺寸 measureChildWithMargins(view, 0, 0); // getDecoratedMeasuredWidth方法是获取此碎片view包含边距和装饰的宽度width int widthSpace = getWidth() - getDecoratedMeasuredWidth(view); int heightSpace = getHeight() - getDecoratedMeasuredHeight(view); mViewInfo = new Rect(); int left = widthSpace / 2; int top = heightSpace / 2; int right = widthSpace / 2 + getDecoratedMeasuredWidth(view); int bottom = heightSpace / 2 + getDecoratedMeasuredHeight(view); mViewInfo.set(left, top, right, bottom); &#125; detachAndScrapView(view, recycler); &#125; LayoutItems(recycler, state);&#125; 我们将view的位置信息使用一个Rect对象来保存，因为layoutDecorated(View child, int left, int top, int right, int bottom)这个函数的参数是整型。Rect和RecF两个对象最大的区别就是精度区别了。 然后将每个子view通过方法detachAndScrapView缓存到scrap内 最后通过LayoutItems(recycler, state)方法将需要展示的view展示出来，注释已经很清楚了哈 1234567891011121314151617181920212223/** * 回收不需要的Item，并且将需要显示的Item从缓存中取出 */private void LayoutItems(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; // 当数量大于临界点才需要回收view boolean isMeetNum = getItemCount() &gt; CardConfig.MAX_SHOW_INDEX + 1; if (isMeetNum) &#123; for (int i = CardConfig.MAX_SHOW_INDEX + 1; i &lt; getItemCount(); i++) &#123; View child = recycler.getViewForPosition(i); removeAndRecycleView(child, recycler); &#125; &#125; // 展示需要展示的view for (int i = isMeetNum ? CardConfig.MAX_SHOW_INDEX : getItemCount() - 1; i &gt;= 0; i--) &#123; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); addView(scrap); //将这个item布局出来 layoutDecorated(scrap, mViewInfo.left, mViewInfo.top, mViewInfo.right, mViewInfo.bottom); int translateY = i * CardConfig.CARD_VERTICAL_GAP; ViewCompat.setTranslationY(scrap, -translateY); &#125;&#125; 这个方法中，将不需要展示的view全部remove，然后将需要展示的view布局出来。 2、使用ItemTouchHelper实现滑动​ ItemTouchHelper是一个为Recyclerview提供 Swipe、drag、drop事件的工具类。使用方法也很简单，推荐大家看泡网的这一片入门文章，思路很清晰。 ​ 本次项目中使用的是ItemTouchHelper本身提供的一个帮助类 SimpleCallback，使用方法其实很简单。它的构造参数有两个值，一个是dragDirs长按的方向，另一个是swipeDirs滑动的方向。可以看看SImpleCallBack的源码： 1234public SimpleCallback(int dragDirs, int swipeDirs) &#123; mDefaultSwipeDirs = swipeDirs; mDefaultDragDirs = dragDirs;&#125; ​ 而我们只需要滑动，所以构造参数中只需要实现 swipe 即可： 12//不支持长按拖拽，支持swipe，而且四个方向皆可以swipethis(0, ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT） ​ 然后应用此 ItemTouchHelper 即可： 123CardItemTouchHelperCallback cardCallback = new CardItemTouchHelperCallback(mRecyclerView, mRecyclerView.getAdapter(), list);ItemTouchHelper touchHelper = new ItemTouchHelper(cardCallback);touchHelper.attachToRecyclerView(mRecyclerView); ​ 到这里 Recyclerview已经实现了四个方向的滑动了，但滑动之后的操作还需要再实现一下。我们在 onSwiped(RecyclerView.ViewHolder viewHolder, int direction) 方法中实现 swipe之后的操作。这个方法有两个参数，viewHolder代表的就是此时滑动的viewholder，direction 代表的是这个view最终滑动的方向。在这个方法里，我们对数据源进行操作，然后刷新列表。 在Recyclerview的Adapter的数据刷新上，我使用了扩展包提供的 DiffUtils,是google提供的替换 notifyDataSetChanged()无脑刷 的方案。 ​ 最后在 onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) 方法中实现滑动时的动画。这个方法有多达七个参数，我来依次解释一下： c ，Recyclerview用来绘制children的画笔 recyclerView，额……就是所依赖的Recyclerview viewHolder，当下滑动的这个view的viewHolder dX、dY，手指在控制滑动的时候，此view水平X轴和垂直Y轴位移的距离，单位像素 actionState，标明此时是长按拖拽还是单纯的swipe isCurrentlyActive，标明此时滑动的view是处于手指控制状态，还是手指松开后的回弹动画状态 ​ 了解了参数之后，在这个方法中就可以实现滑动时的动画了。SimpleCallBack 默认的对滑动距离判断的条件是，水平方向是Recyclerview宽的一半，垂直方向是Recyclerview高的一半。 1234//这个方法返回的值就是默认的阙值，想要更灵敏的话只需在自定义CallBack中重写这个方法，将值变小。更迟钝的话则反之public float getSwipeThreshold(ViewHolder viewHolder) &#123; return .5f;&#125; ​ 撸出来的代码如下： 1234567891011121314151617181920212223242526272829303132@Override public void onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) &#123; super.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive);// Log.d(TAG, &quot;onChildDraw dX : &quot; + dX);// Log.d(TAG, &quot;onChildDraw dY : &quot; + dY); Log.d(TAG, &quot;onChildDraw isCurrentlyActive: &quot; + isCurrentlyActive); if (mItemW == 0) &#123;// Log.d(TAG, &quot;onChildDraw getAdapterPosition : &quot; + viewHolder.getAdapterPosition()); mItemW = viewHolder.itemView.getWidth(); mHorJudgeDistance = recyclerView.getWidth() * getSwipeThreshold(viewHolder); mVerJudgeDistance = recyclerView.getHeight() * getSwipeThreshold(viewHolder); &#125; float ratio; if (Math.abs(dX) &gt; Math.abs(dY)) &#123; //以宽为判定基准 ratio = Math.abs(dX) / mHorJudgeDistance; &#125; else &#123; //以高为判定基准 ratio = Math.abs(dY) / mVerJudgeDistance; &#125; float realRatio = ratio &gt;= 1f ? 1f : ratio; ViewCompat.setAlpha(viewHolder.itemView, 1 - realRatio); boolean isMeetNum = recyclerView.getLayoutManager().getItemCount() &gt; CardConfig.MAX_SHOW_COUNT + 1; int maxJudge = isMeetNum ? CardConfig.MAX_SHOW_COUNT - 1 : (recyclerView.getLayoutManager().getItemCount() - 1); for (int i = 1; i &lt;= maxJudge; i++) &#123; View itemView = recyclerView.findViewHolderForAdapterPosition(i).itemView; float v = i * CardConfig.CARD_VERTICAL_GAP - realRatio * CardConfig.CARD_VERTICAL_GAP; ViewCompat.setTranslationY(itemView, -v); &#125; &#125; 3、使用ItenAnimator实现回滚动画​ ItemAnimator 我没有选择实现，而是使用了现成的轮子recyclerview-animators，没有选择远程库引入。而是将源代码copy进来，再进行了适当性的修改。 12mRecyclerView.setItemAnimator(new SlideAnimator());mRecyclerView.getItemAnimator().setAddDuration(250); ​ OK，到这里基本上就大功告成了，只剩下一些小细节和bug处理一下即可。在CallBack 类的 onSwipe 方法中将 direction 赋值到一个静态变量中，然后在 SlideAnimator 根据不同的方向实现不同的动画。 ​ 在实现过程中，我发现回滚动画的那个view居然不是滑走的view，就使用了一个单例来管理数据。动画开始时将数据设置为滑走的view的数据，动画结束后再将动画view的数据还原。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Overrideprotected void preAnimateAddImpl(RecyclerView.ViewHolder holder) &#123; Log.d(TAG, &quot;preAnimateAddImpl: &quot; + holder.itemView.getTag().toString()); DataExchangeMgr.getInstance().saveOrignData((int) holder.itemView.getTag(R.id.view_data)); //根据不同的方向设置不同的初始值 if (isHorizDirection()) &#123; int width = holder.itemView.getRootView().getWidth(); ViewCompat.setTranslationX(holder.itemView, CardConfig.sViewholderDirection == ItemTouchHelper.LEFT ? -width : width); &#125; else &#123; int height = holder.itemView.getRootView().getHeight(); ViewCompat.setTranslationY(holder.itemView, CardConfig.sViewholderDirection == ItemTouchHelper.UP ? -height : height); &#125;&#125;@Overrideprotected void animateAddImpl(final RecyclerView.ViewHolder holder) &#123; //根据不同的方向选择不同的动画 ViewPropertyAnimatorCompat viewPropertyAnimatorCompat = ViewCompat.animate(holder.itemView) .setDuration(getAddDuration()) .setInterpolator(mInterpolator) .setListener(new DefaultAddVpaListener(holder) &#123; @Override public void onAnimationStart(View view) &#123; super.onAnimationStart(view); //将此view数据设置为滑开的数据 ((ImageView) mViewHolder.itemView.findViewById(R.id.show_img)).setImageResource(DataExchangeMgr.getInstance().getCurrentData()); &#125; @Override public void onAnimationCancel(View view) &#123; super.onAnimationCancel(view); //数据还原 ((ImageView) mViewHolder.itemView.findViewById(R.id.show_img)).setImageResource(DataExchangeMgr.getInstance().getOrignalData()); &#125; @Override public void onAnimationEnd(View view) &#123; super.onAnimationEnd(view); //数据还原 ((ImageView) mViewHolder.itemView.findViewById(R.id.show_img)).setImageResource(DataExchangeMgr.getInstance().getOrignalData()); &#125; &#125;) .setStartDelay(50); if (isHorizDirection()) &#123; viewPropertyAnimatorCompat .translationX(0) .start(); &#125; else &#123; viewPropertyAnimatorCompat .translationY(0) .start(); &#125;&#125;private boolean isHorizDirection() &#123; return CardConfig.sViewholderDirection == ItemTouchHelper.LEFT || CardConfig.sViewholderDirection == ItemTouchHelper.RIGHT;&#125; 最后感兴趣的可以看看代码，奉上GitHub地址。InfinateCard","path":"2017/05/10/android-infinite-card/","date":"05-10","excerpt":"","tags":[{"name":"Android","slug":"Android","permalink":"https://yoursite.com/tags/Android/"},{"name":"交互体验","slug":"交互体验","permalink":"https://yoursite.com/tags/交互体验/"}],"preview":"https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/20170510-blog-header-bg.jpg"},{"title":"Android萤火虫飞舞粒子效果","text":"GitHub地址 原创文章，转载请注明出处 萤火虫飞舞粒子效果 本项目中我提供了两种方案，最终呈现的效果如下： 先奉上GitHub地址戳这里，有兴趣的同鞋star一下咯 实现原理Android的粒子效果、粒子动画，已经有很多开源的轮子了。作为一个坚定的轮子主义者，我google了大半天，却没有找到这种类似于萤火虫飞舞的效果。只好自己来实现这种效果。 相比较普通的View，SurfaceView更加适合这种不断变化的画面，所以选择SurfaceView来实现。现在把思路再重新梳理一下： 大小不同的粒子在区域内随机分布 粒子做无规则运动，然后消失 粒子区域内随机分布这个简单，我们在callBack的方法内直接循环生成一个粒子的数组即可。方位的话使用Random即可。 1234567891011121314151617if (mCircles.size() == 0) &#123; for (int i = 0; i &lt; MAX_NUM; i++) &#123; FloatParticleLine f = new FloatParticleLine(getF() * mMeasuredWidth, getF() * mMeasuredHeight, mMeasuredWidth, mMeasuredHeight); f.setRadius(mRandom.nextInt(2) + 1.2f); mCircles.add(f); &#125;&#125;private float getF() &#123; float v = mRandom.nextFloat(); if (v &lt; 0.2f) &#123; return v + 0.2f; &#125; else if (v &gt;= 0.85f) &#123; return v - 0.2f; &#125; else &#123; return v; &#125; &#125; getF（）方法是限制在区域内取值，mMeasuredWidth、mMeasuredHeight为SurfaceView的宽和高。 这里的宽和高在粒子对象FloatParticleLine，内会用到。 然后我们在创建一个线程，在run（）方法内做无线循环的绘制即可，为了避免无意义的绘制，可以使用Thread.sleep方法来控制帧数。 1234567891011121314151617181920212223while (isRun) &#123; try &#123; mCanvas = mHolder.lockCanvas(null); if (mCanvas != null) &#123; synchronized (mHolder) &#123; // 清屏 mCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR); for (FloatParticleLine circle : mCircles) &#123; circle.drawItem(mCanvas); &#125; // 控制帧数 Thread.sleep(25); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (mCanvas != null) &#123; mHolder.unlockCanvasAndPost(mCanvas); &#125; &#125;&#125; isRun的变量我们会在SurfaceView内callBack的surfaceDestroyed方法中置为false 粒子做无规则运动 方案一 其实看到这种粒子效果，首先应该想到的就是Canvas了。 在SurfaceView里就是通过不断地循环调用FloatParticleLine类的drawItem（）方法来实现粒子的运动。我第一种方案的实现，就是每一个粒子在被创建出来的时候，就随机选择一个方向开始运动，滑过一定的轨迹之后让其消失就好了。 至于怎么选择随机方向，我这里的做法是，分别随机生成一个x和y轴上的递增或者递减的数值，然后每次在前一次绘制的基础上，x和y分别递增递减，直到运动到屏幕边缘或者是规定的运动距离满足了再消失即可。 12345678910111213//随机生成参数private void setRandomParm() &#123; // 2017/5/2-上午10:47 x和y的方向 mIsAddX = mRandom.nextBoolean(); mIsAddY = mRandom.nextBoolean(); // 2017/5/2-上午10:47 x和y的取值 mDisX = mRandom.nextInt(2) + 0.2f; mDisY = mRandom.nextInt(2) + 0.3f; // 2017/5/2-上午10:47 内部区域的运动最远距离 mDistance = mRandom.nextInt((int) (0.25f * mWidth)) + (0.125f * mWidth);&#125; 绘制图形： 1234567891011121314151617181920212223242526272829303132public void drawItem(Canvas canvas) &#123; if (mX == mStartX) &#123; mPaint.setAlpha(ALPHA_MAX); &#125; //绘制 canvas.drawCircle(mX += getPNValue(mIsAddX, mDisX), mY += getPNValue(mIsAddY, mDisY), mRadius, mPaint); //内部区域运动到一定距离消失 if (judgeInner()) &#123; float gapX = Math.abs(mX - mStartX); float ratio = 1 - (gapX / mDistance); mPaint.setAlpha((int) (255 * ratio)); mRadius = mStartRadius * ratio; if (gapX &gt;= mDistance || mY - mStartY &gt;= mDistance) &#123; resetDisXY(); return; &#125; return; &#125; //外部区域运动到屏幕边缘消失 if (judgeOutline()) &#123; resetDisXY(); &#125;&#125;private void resetDisXY() &#123; setRandomParm(); mPaint.setAlpha(0); mX = mStartX; mY = mStartY; mRadius = mStartRadius; &#125; judgeInner()和judgeOutline()是判断区域的方法，内部区域的点和外部区域的店消失时机不同 在透明度为0也就是粒子消失时，让粒子回到原点，再重新选择一个方向，进行下一步运动轨迹。 方案二 方案二粒子做的运动是贝塞尔曲线，函数实在网上找到的一个函数。每当粒子做完一次曲线运动后，再随机生成一段新的贝塞尔曲线即可。 思路和方案一的思路都是一样的，无非就是运动的轨迹不同而已。 总结做完之后回头再看，发现这个项目的原理其实并不难，可以说是简单了。但刚开始起步的时候真的还是比较懵的，原因就是没有思路。 所以做任何效果，思路最重要。","path":"2017/04/28/android-firefly/","date":"04-28","excerpt":"","tags":[{"name":"Canvas动画","slug":"Canvas动画","permalink":"https://yoursite.com/tags/Canvas动画/"},{"name":"Android","slug":"Android","permalink":"https://yoursite.com/tags/Android/"}],"preview":"https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/20170428-blog-header-bg.jpg"},{"title":"Hello World","text":"Hello World","path":"2017/04/28/hello-world/","date":"04-28","excerpt":"","tags":[]}]}