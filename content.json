{"pages":[{"title":"404","text":"","path":"404/index.html","date":"04-24","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"04-24","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"04-24","excerpt":""}],"posts":[{"title":"文字动次打次，让文字动态绘制出来","text":"本文属于Android技术论述文章，阅读完大致需要五分钟 原创文章，转载请注明出处。 没时间的小伙伴可以直接跳过文章，点击项目地址，如果喜欢的话，顺手给个star那是极好的【娇羞……】 二话不说，效果奉上！ 知识点序列： Canvas绘制 TextPaint Path PathMeasure【测量Path】 代码分析获取文字的轮廓Path在TextPaint中有这样一个方法，getTextPath,如下： 12345678public void getTextPath(String text, int start, int end, float x, float y, Path path) &#123; if ((start | end | (end - start) | (text.length() - end)) &lt; 0) &#123; throw new IndexOutOfBoundsException(); &#125; nGetTextPath(mNativePaint, mNativeTypeface, mBidiFlags, text, start, end, x, y, path.mutateNI()); &#125; 👀其中nGetTextPath里面是调用了一个原生函数，具体实现不必理会。只需要了解函数的各个参数就可以了。 参数含义： text：文本内容 start：需要测量的文本中的第一个字符的下标 end：需要测量的文本最后一个字符的下标加1 x：Path起点的坐标X y：Path起点的坐标Y path：最终测量得到的Path Path分段绘制PathMeasure这个类可以说是Path相关的工具解析类，里面大多是原生函数，实现细节不必深究。只需要会使用方法即可。第一步我们得到文字的轮廓Path之后，这一步将此path按段绘制出来即可。在代码中，由CanvasView这个类来具体实现绘制的详尽流程。看代码，将文本轮廓Path设置进来： 123456789101112131415161718// 保留一份原始Path，用作绘制最终填色的文字 mOrignalPath = orignalPath; if (null == mPathMeasure) &#123; mPathMeasure = new PathMeasure(); &#125; //先重置一下需要显示动画的path mAnimPath.reset(); mAnimPath.moveTo(0, 0); mPathMeasure.setPath(orignalPath, false); // getLength（）方法获得的是当前path的长度；而nextContour（）方法是将Path切换到下一段Path，多应用在复杂path中 mTextCount = 0; // 计算文字总共有多少段Path while (mPathMeasure.nextContour()) &#123; mTextCount++; &#125; // PathMeasure重新设置一次 mPathMeasure.setPath(orignalPath, false); mPaint.setStyle(Paint.Style.STROKE); 其中成员变量mAnimPath，即是用在onDraw()方法内用于绘制的Path。我们会不停地通过PathMeasure刷新这个Path，用于动画流畅运行。 接下来是引擎代码，使用的是属性动画，看代码实现： 1234567891011121314151617181920212223242526272829if (null == mValueAnimator) &#123; // 如果一个文本Path包含n个小Path，那么属性动画会Repeat运行n次，每一段小path默认动画时间为900ms mValueAnimator = ValueAnimator.ofFloat(0.0f, 1.0f); mValueAnimator.setDuration(900); mValueAnimator.setInterpolator(new LinearInterpolator()); &#125; // 引擎无限次重复发动 mValueAnimator.setRepeatCount(ValueAnimator.INFINITE); mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float value = (float) animation.getAnimatedValue(); // 将一段小Path从0%到100%赋值到mAnimPath中，调用重绘 mPathMeasure.getSegment(0, mPathMeasure.getLength() * value, mAnimPath, true); invalidate(); &#125; &#125;); mValueAnimator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationRepeat(Animator animation) &#123; super.onAnimationRepeat(animation); //绘制完一条Path之后，再绘制下一条，直到完成为止。 if (!mPathMeasure.nextContour()) &#123; animation.end(); &#125; invalidate(); &#125; &#125;); 注释里具体原因亦已写明。这种引擎的设置，就是每一小段Path不管长短，其绘制时间都是相等的，会造成动画看起来时慢时快。 其实要让动画一直匀速跑起来也很容易，就是提前将原始Path测量一遍，设置一个总时间，然后根据小Path的长短来按照比例分配时间。这样即可使动画匀速进行。具体代码不再多言😘，有兴趣的小伙伴可以试试。 再看看CanvasView内的onDraw()方法实现： 12345678910@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (null != mPathMeasure &amp;&amp; mPathMeasure.getLength() == 0) &#123; mPaint.setStyle(Paint.Style.FILL); canvas.drawPath(mOrignalPath, mPaint); return; &#125; canvas.drawPath(mAnimPath, mPaint); &#125; 这里面的代码更加简单，在Path绘制完之前，一直绘制mAnimPath即可。Path绘制完之后，设置画笔的绘制风格，将文字空白处填上色即可。 以上。就是本次项目的主要思路解析。大家走过路过不要错过，给添个Star呗😄。","path":"2017/11/02/anim_text/","date":"11-02","excerpt":"","tags":[{"name":"Canvas动画","slug":"Canvas动画","permalink":"https://yoursite.com/tags/Canvas动画/"},{"name":"Android","slug":"Android","permalink":"https://yoursite.com/tags/Android/"}],"preview":"https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/20170819-blog-header-bg.jpg"},{"title":"实现薄荷Loading动画","text":"本文属于Android技术论述文章，阅读完大致需要五分钟 原创文章，转载请注明出处。 没时间的小伙伴可以直接跳过文章，点击项目地址，如果喜欢的话，顺手给个star那是极好的【娇羞……】 好吧。先说一下为什么要做这个项目。前几天使用薄荷的时候，凑巧看到了这个Loading动画，觉得效果还不错。就想尝试着实现一下。先看一下原版的效果，GIF录制的比较快，但应该还可以看清楚。 先上本次最终实现的效果图吧，颜色当然选择今年最流行的原谅色： 思路分析 1、整个图形的形状如何绘制 2、如何让线条动起来 整个图形的形状分析 好了，首先我们来分析一下这个图案，如果是静态的，那么如何绘制？很简单，拆分。我们将图形拆开分解，然后再看。分析细节和步骤，这是要点。我这里将这个图分成了三份。 第一个，也就是叶柄。也就是下面那一条小小的竖线。原Loading图中不甚明显，但还是有的。叶柄没什么说的，直线就可以了。 第二个，叶子的左轮廓边缘和右轮廓边缘。这是一段下肥上窄的弧线，椭圆截取感觉不妥，我这里采用的是贝塞尔二阶曲线。有关Android贝塞尔相关的知识大家可以看看这篇文章。 第三个，也就是叶片的脉络，线和线交叉连接，没什么可说的。 那么重点其实就是叶子左右轮廓的绘制了，我画了一张草图。大家可以看看： 其中黑色的框作为View的边界。A点是左轮廓曲线的起点，B点事贝塞尔曲线的控制点，我把它定义到了View的左边框那里。C点事整个贝塞尔曲线的终点，D点则是实际上曲线的最高点。右轮廓则和左轮廓是镜像存在。图有点潦草，不过应该还看得懂。 好了，静态图形拆解完毕。接着看，如何让图动起来。 如何让线条动起来整个项目中，如何让线条真正的动起来才是要点。刚开始在这里的思路，是想使用canvas.drawCircle绘制在一张Bitmap上，以点汇面。后面实现起来发现，这种方式特别不靠谱。为什么不靠谱呢？因为点连接成线，每次移动的速率和距离都得计算，很麻烦。很容易出现断点的情况。最后，我采用的是让canvas去绘制一段Path路径，然后Path路径不停的刷新改变。这样做的好处，是Path更加直观易于控制。而且还不用多绘制一张Bitmap。整个项目中，自定义的View，LeafAnimView做的工作很少，只是在onDraw方法内，调起了绘制而已。具体的绘制都交给LeafAtom了。面向对象嘛。 具体的思路，是我把总时间按比例分成四部分。生成四个属性动画，在属性动画的监听里作Path的x和y的变化。在绘制的时候，只需要将这四个动画依次播放，即可得到每个时间段的具体运动值。而且还是均匀变化的。 LeafAnimView内部作为动画引擎的是一个ValueAnimator,使用它来触发View的onDraw。同时也使用它来控制整个动画的时间。 123456789mValueAnimator = ValueAnimator.ofFloat(0, 1); mValueAnimator.setDuration(5000); mValueAnimator.setRepeatCount(ValueAnimator.INFINITE); mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; invalidate(); &#125; &#125;); LeafAtom类内部接受到这个总时长，然后将运动总时间分割，根据比例计算出绘制叶柄、左右轮廓、脉络的动画时间。 123456789101112131415161718192021222324252627282930313233343536-------在LeafAnimView类内部--------- @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (null == mLeafAtom) &#123; //传入总时长 mLeafAtom = new LeafAtom(getWidth(), getHeight(), mValueAnimator.getDuration()); &#125; if (!mValueAnimator.isStarted()) &#123; mValueAnimator.start(); &#125; //开始绘制 mLeafAtom.drawGraph(canvas, mPaint); &#125; -------在LeafAtome类---------------public static final float PETIOLE_RATIO = 0.1f;//叶柄所占比例public LeafAtom(int width, int height, long duration) &#123; mWidth = width; mHeight = height; mPetioleTime = (long) (duration * PETIOLE_RATIO);//绘制叶柄的时间 mArcTime = (long) (duration * (1 - PETIOLE_RATIO) * 0.4f);//左右轮廓弧线的时间 mLastLineTime = duration - mPetioleTime - mArcTime * 2;//最后一段叶脉的时间 mBezierBottom = new PointF(mWidth * 0.5f, mHeight * (1 - PETIOLE_RATIO));//左侧轮廓底部点 mBezierControl = new PointF(0, mHeight * (1 - 3 * PETIOLE_RATIO));//左侧轮廓控制点 mBezierTop = new PointF(mWidth * 0.5f, 0);//左侧轮廓顶部结束点 mVeinBottomY = mHeight * (1 - PETIOLE_RATIO) - 10;//右侧轮廓底部点Y轴坐标，稍稍低一点 mOneNodeY = mVeinBottomY * 4 / 5;//第一个节点的Y轴坐标 mTwoNodeY = mVeinBottomY * 2 / 5;//第二个节点Y轴坐标 initEngine(); setOrginalStatus(); &#125; 在LeafAtom的构造函数中，得到每一个阶段动画的时间，然后生成四个属性动画，在这个属性动画的监听里去做Path的x和y坐标的值变化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 初始化path引擎 */ private void initEngine() &#123; //叶柄动画，Y轴变化由底部运动到叶柄高度的地方 mPetioleAnim = ValueAnimator.ofFloat(mHeight, mHeight * (1 - PETIOLE_RATIO)).setDuration(mPetioleTime); //左右轮廓贝塞尔曲线，只需要只奥时间变化是从0~1的。起点、控制点、结束点都知道了 mArcAnim = ValueAnimator.ofFloat(0, 1.0f).setDuration(mArcTime); //绘制叶脉的动画 mLastAnim = ValueAnimator.ofFloat(mVeinBottomY, 0).setDuration(mLastLineTime); mPetioleAnim.setInterpolator(new LinearInterpolator()); mArcAnim.setInterpolator(new LinearInterpolator()); mLastAnim.setInterpolator(new LinearInterpolator()); mArcRightAnim = mArcAnim.clone(); mPetioleAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mY = (float) animation.getAnimatedValue(); &#125; &#125;); mArcAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; computeArcPointF(animation, true); &#125; &#125;); mArcRightAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; computeArcPointF(animation, false); &#125; &#125;); mLastAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mY = (float) animation.getAnimatedValue(); float tan = (float) Math.tan(Math.toRadians(30)); if (mY &lt;= mOneNodeY &amp;&amp; mY &gt; mTwoNodeY) &#123; mOneLpath.moveTo(mX, mOneNodeY); mOneRpath.moveTo(mX, mOneNodeY); //这里的参数x和y代表相对当前位置偏移量，y轴不加偏移量会空一截出来，这里的15是经验值 mMainPath.addPath(mOneLpath, 0, EXPRIENCE_OFFSET); mMainPath.addPath(mOneRpath, 0, EXPRIENCE_OFFSET); //第一个节点和第二个节点之间 float gapY = mOneNodeY - mY; mOneLpath.rLineTo(-gapY * tan, -gapY); mOneRpath.lineTo(mX + gapY * tan, mY); &#125; else if (mY &lt;= mTwoNodeY) &#123; mTwoLpath.moveTo(mX, mTwoNodeY); mTwoRpath.moveTo(mX, mTwoNodeY); //第二个节点，为避免线超出叶子，取此时差值的一半作计算 float gapY = (mTwoNodeY - mY) * 0.5f; mMainPath.addPath(mTwoLpath, 0, EXPRIENCE_OFFSET); mMainPath.addPath(mTwoRpath, 0, EXPRIENCE_OFFSET); mTwoLpath.rLineTo(-gapY * tan, -gapY); mTwoRpath.rLineTo(gapY * tan, -gapY); &#125; &#125; &#125;); mEngine = new AnimatorSet(); mEngine.playSequentially(mPetioleAnim, mArcAnim, mArcRightAnim, mLastAnim); mEngine.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); setOrginalStatus(); &#125; &#125;); &#125; 计算贝塞尔曲线运动过程中的方法。贝塞尔曲线是有一个函数的，我们知道起点、控制点、终点的话，就可以根据时间计算出此时此刻的x和y的坐标。而这个时间变化是从0~1变化的。谨记。 1234567891011121314151617private void computeArcPointF(ValueAnimator animation, boolean isLeft) &#123; float ratio = (float) animation.getAnimatedValue(); //ratio从0~1变化，左右轮廓三个点不一样 PointF bezierStart = isLeft ? mBezierBottom : mBezierTop; PointF bezierControl = isLeft ? mBezierControl : new PointF(mWidth, mHeight * (1 - 3 * PETIOLE_RATIO)); PointF bezierEnd = isLeft ? mBezierTop : new PointF(mWidth * 0.5f, mVeinBottomY); PointF pointF = calculateCurPoint(ratio, bezierStart, bezierControl, bezierEnd); mX = pointF.x; mY = pointF.y; &#125; private PointF calculateCurPoint(float t, PointF p0, PointF p1, PointF p2) &#123; PointF point = new PointF(); float temp = 1 - t; point.x = temp * temp * p0.x + 2 * t * temp * p1.x + t * t * p2.x; point.y = temp * temp * p0.y + 2 * t * temp * p1.y + t * t * p2.y; return point; &#125; 叶脉的绘制，在节点一和节点二，分别加上两个向左和向右伸展开的Path路径即可。 需要说明的是，lineTo和rLineTo的区别，lineTo的参数代表的就是目标参数，而rLineTo的参数代表的是，目标参数和起点参数的差值。 最后在drawGraph函数中，启动这个动画集合： 12345678public void drawGraph(Canvas canvas, Paint paint) &#123; if (mEngine.isStarted()) &#123; canvas.drawPath(mMainPath, paint); mMainPath.lineTo(mX, mY); &#125; else &#123; mEngine.start(); &#125; &#125; 以上，就是本次项目的主要思路了。相关注释代码里都写的很清楚了，项目地址在这里。仿薄荷Loading动画，大家走过路过千万别忘了给个Star啊。","path":"2017/08/19/bohe_path/","date":"08-19","excerpt":"","tags":[{"name":"Canvas动画","slug":"Canvas动画","permalink":"https://yoursite.com/tags/Canvas动画/"},{"name":"Android","slug":"Android","permalink":"https://yoursite.com/tags/Android/"}],"preview":"https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/20170819-blog-header-bg.jpg"},{"title":"实用性MAX!像普通View一样自由使用的粒子组件","text":"原创文章，转载请注明出处。之前作过一篇萤火虫飞舞粒子效果，当时看还不错。无论是性能还是UI都满足了当时的设计效果，但实际应用到项目中，却发现由于SurfaceView其本身是绘制在window层面上的，对View本身的属性有很多的限制，用起来却不是很实在，还存在着很多不足。 于是便将之前的效果重新写了一下，改用继承View来实现，虽然说和SurfaceView相比，在绘制性能上有那么一丝丝的不足 。但轮子本质的含义还是为了服务于项目，项目中方便的使用才是最重要的。 阅读本文，大概需要三分半钟。如果需要直观看代码的话请点这里点这里！！首先看一下效果图 接着分析实现过程中的几个问题 如何保持不间断的绘制 粒子的运动轨迹控制（随机方向，碰到边界回弹以及旋转） 问题1：如何保持不间断的绘制​ View 的粒子绘制本身实在onDraw中进行的，所以最开始我的方案是在canvas绘制完一波之后，继续调用 invalidate()方法，这样就形成了一个死循环，就达到了不间断重复绘制的效果。 1234567891011@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(); //粒子的一波绘制 for (Particle circle : mCircles) &#123; circle.drawItem(canvas); &#125; canvas.restore(); invalidate();&#125; 这里需要注意的是，canvas的绘制是一个阻塞的过程，也就是从canvas.save()方法之后，一直到invalidate()之前，是阻塞的。 重绘是会一直等到所有的粒子绘制完成之后，才会继续调起的。 Tips： canvas的save和restore方法是搭配使用的。save存储之前的canvas状态，restore恢复save之前的状态。 save方法是可以多次使用的，可以搭配使用的是方法restoreToCount(saveCount)。参数saveCount从1开始计数，表示可以恢复到第几次save之前的状态。 ​ 这种方式的缺点在demo完成之后很明显的体现了出来。第一，速度不可控制，譬如有些时候恰恰需要粒子变慢一点呢。使用这种方式就不太好实现了。第二，粒子动画的播放和暂停实现起来不优雅，诚然写一个布尔值来控制也可以，但也难免………………太不优雅了吧。反正我个人是比较不喜欢写这种代码的。 ​ 那么，最终我的实现方式，是采用了属性动画来实现的，没错——就是ValueAnimator。来看代码： 123456789101112private ValueAnimator mParticleAnim;-----------------mParticleAnim = ValueAnimator.ofInt(0).setDuration(30);mParticleAnim.setRepeatCount(ValueAnimator.INFINITE);mParticleAnim.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationRepeat(Animator animation) &#123; super.onAnimationRepeat(animation); Log.d(TAG, &quot;onAnimationRepeat: &quot; + System.currentTimeMillis()); invalidate(); &#125;&#125;); 这段代码展示出来，你懂得。 在一个无限循环的属性动画里，在Repeat监听事件里，调用View的invalidate方法重绘。这样每次触发重绘的时间间隔就是属性动画的持续时间。 要是想控制粒子的运动速率，那么只需要调整动画的持续时间即可。 而且如果要对外暴露粒子动画开始或者停止的方法，只需要控制属性动画的start和stop就行了。 问题2：粒子的运动轨迹​ 在构建轮子的时候，思路其实一直都很清晰。View层级主要是调起和控制绘制。具体要绘制什么东西和路线的控制都由粒子对象内部来实现。这样就可以贯彻单一原则，各自负责各自的东西，降低耦合性。 ​ 我们来看一下粒子对象Particle内的代码： 1234567891011121314151617181920212223242526272829303132333435public Particle(Bitmap drawBitmap, Matrix matrix, Paint paint, float x, float y, int width, int height) &#123; //绘制的bitmap对象和矩阵对象，矩阵用来控制旋转和运动方向 mDrawBitmap = drawBitmap; mBitmapMatrix = matrix; mDrawBitmapWidth = drawBitmap.getWidth(); mDrawBitmapHeight = drawBitmap.getHeight(); mBitmapCenterX = mDrawBitmapWidth / 2f; mBitmapCenterY = mDrawBitmapHeight / 2f; //画笔对象 mPaint = paint; //view 的宽和高用来判断边界 this.mWidth = width; this.mHeight = height; //粒子运动的坐标 this.mX = x; this.mY = y; //粒子的开始坐标 mStartX = x; mStartY = y; //x 和y轴的运动方向选择，随机函数 mIsAddX = mRandom.nextBoolean(); mIsAddY = mRandom.nextBoolean(); setRandomParm();&#125;private void setRandomParm() &#123; //x 和 y轴每次运动的距离和每次旋转的角度，随机值 mDisX = mRandom.nextInt(2) + 1.2f; mDisY = mRandom.nextInt(2) + 1.2f; mAddDegree = mRandom.nextInt(5) + 3f;&#125; ​ 运动轨迹这方面只需要随机出来x和y轴的方向，还有每次递增或者递减的值即可。怎么样是不是丝毫没有技术难度啊。好了，看绘制和到边界的处理代码吧。 123456789101112131415161718192021222324252627282930313233343536public void drawItem(Canvas canvas) &#123; //绘制 mBitmapMatrix.reset(); mBitmapMatrix.preTranslate(mX += getPNValue(mIsAddX, mDisX), mY += getPNValue(mIsAddY, mDisY)); mBitmapMatrix.preRotate(mDegrees += mAddDegree, mBitmapCenterX, mBitmapCenterY); canvas.drawBitmap(mDrawBitmap, mBitmapMatrix, mPaint); Log.d(TAG, &quot;mX : &quot; + mX); Log.d(TAG, &quot;mY : &quot; + mY); judgeOutline();&#125;private void judgeOutline() &#123; boolean judgeX = mX &lt;= 0 || mX &gt;= (mWidth - mDrawBitmapWidth); boolean judgeY = mY &lt;= 0 || mY &gt;= (mHeight - mDrawBitmapHeight); if (judgeX) &#123; mIsAddX = !mIsAddX; mIsAddY = mRandom.nextBoolean(); setRandomParm(); if (mX &lt;= 0) &#123; mX = 0; &#125; else &#123; mX = mWidth - mDrawBitmapWidth; &#125; return; &#125; if (judgeY) &#123; mIsAddY = !mIsAddY; mIsAddX = mRandom.nextBoolean(); setRandomParm(); if (mY &lt;= 0) &#123; mY = 0; &#125; else &#123; mY = mHeight - mDrawBitmapHeight; &#125; &#125;&#125; ​ 以上就是粒子对象内部的运动轨迹和边界判断代码了，怎样，是不是超级简单呢？ ​ 好了，如果你喜欢我的文章的话，那么请不要犹豫，给我一个star吧。GitHub地址：这里这里！！","path":"2017/06/28/android_partical/","date":"06-28","excerpt":"","tags":[{"name":"Canvas动画","slug":"Canvas动画","permalink":"https://yoursite.com/tags/Canvas动画/"},{"name":"Android","slug":"Android","permalink":"https://yoursite.com/tags/Android/"}],"preview":"https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/20170628-blog-header-bg.jpg"},{"title":"低消耗、带回滚动画的仿探探交互效果","text":"原创文章，转载请注明出处。 前段时间项目中有一个仿探探的交互界面，写代码的过程中，觉得效果还不错。就把思路和原理记录了下来，分享一下。 先奉上GitHub地址，大家感兴趣可以来个starInfinateCard 套路还是要走一下的，先给大家看一下效果图: 真机上一点都不卡！一点都不卡！不卡！！！ 又学习了一些录制GIF的方法，这次来一张真机的效果！！ 会用到的知识点 Recyclerview的layoutManager实现布局 使用ItemTouchHelper处理滑动事件 手指滑动过程中，view的UI渐变（透明度或者其它） RecyclerView的ItemAnimator实现回滚动画 1、LayoutManger众所周知，Recyclerview之所以强大，完全在于它百变的适应性。它能实现任何你想要的布局样式，而它的奥秘就在于LayoutManger。 ​ 本次项目中我们UI效果仿照探探的样式，是卡牌样式的堆叠效果，按照List集合的顺序沿着Z轴纵向深处排列。这里有一个值得注意的Tip，子view是按照list集合的顺序去绘制的，也就是在这个我们自定义的LayoutManger里，第二个view会覆盖第一个，第三个会覆盖第二个，以此类推。如果我们想要第一眼就看到List集合的第一个，那么必须将list集合reverse后，再来绘制。 ​ 好了，我们来看代码。LayoutManger的精髓其实就在于onLayoutChildren（……）这个方法，通过这个方法来实现自定义的布局。 12345678910111213141516171819@Overridepublic void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; int itemCount = getItemCount(); // 代码的稳健之道，就在于该保护的地方一定要保护 if (itemCount == 0) &#123; return; &#125; detachAndScrapAttachedViews(recycler); for (int position = 0; position &lt; itemCount; position++) &#123; View view = recycler.getViewForPosition(position); addView(view); measureChildWithMargins(view, 0, 0); int widthSpace = getWidth() - getDecoratedMeasuredWidth(view); int heightSpace = getHeight() - getDecoratedMeasuredHeight(view); // recyclerview 布局 layoutDecoratedWithMargins(view, widthSpace / 2, heightSpace / 2, widthSpace / 2 + getDecoratedMeasuredWidth(view), heightSpace / 2 + getDecoratedMeasuredHeight(view)); &#125; ​ 很多人看到这里，肯定会喷出一句“卧槽！这就完了，就这点代码？” ​ 没错，如果不追求精细的话，这点代码确实可以搞定这个布局样式。现在我们来逐行分析一下代码。 detachAndScrapAttachedViews(recycler)这个方法就是将所有的view缓存在scrap里。Recyclerview有二级缓存，scrap和Recycle。使用Detach方式处理的view缓存在scrap里，用的时候不需要重新绑定数据。Remove方式处理的view缓存在Recycle里，使用的时候会重新绑定数据。 接下来的for循环代码就简单的多了，无非就是获得view的宽高信息，将其布局在Recyclerview内 当然，如果只是以上那些简单的代码，未免也太对不起Recyclerview了。毕竟Recyclerview最强大的地方就是对view的回收和利用了，要不然为什么叫Recycler呢。 对子view的回收利用​ 首先这种卡牌叠层的交互模式，不需要展示那么多的view，也就是我们仅仅需要让前几个view展示出来就可以了。其他的view，放在scrap缓存里即可。 12345678910111213141516171819202122232425262728293031@Overridepublic void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; int itemCount = getItemCount(); // 代码的稳健之道，就在于该保护的地方一定要保护 if (itemCount == 0) &#123; return; &#125; detachAndScrapAttachedViews(recycler); // 测量子view的位置信息并储存 for (int position = 0; position &lt; itemCount; position++) &#123; // 根据position获取一个碎片view，可以从回收的view中获取，也可能新构造一个 View view = recycler.getViewForPosition(position); Log.d(TAG, &quot;recycler&quot; + view.getTag().toString()); addView(view); if (mViewInfo == null) &#123; // 计算此碎片view包含边距的尺寸 measureChildWithMargins(view, 0, 0); // getDecoratedMeasuredWidth方法是获取此碎片view包含边距和装饰的宽度width int widthSpace = getWidth() - getDecoratedMeasuredWidth(view); int heightSpace = getHeight() - getDecoratedMeasuredHeight(view); mViewInfo = new Rect(); int left = widthSpace / 2; int top = heightSpace / 2; int right = widthSpace / 2 + getDecoratedMeasuredWidth(view); int bottom = heightSpace / 2 + getDecoratedMeasuredHeight(view); mViewInfo.set(left, top, right, bottom); &#125; detachAndScrapView(view, recycler); &#125; LayoutItems(recycler, state);&#125; 我们将view的位置信息使用一个Rect对象来保存，因为layoutDecorated(View child, int left, int top, int right, int bottom)这个函数的参数是整型。Rect和RecF两个对象最大的区别就是精度区别了。 然后将每个子view通过方法detachAndScrapView缓存到scrap内 最后通过LayoutItems(recycler, state)方法将需要展示的view展示出来，注释已经很清楚了哈 1234567891011121314151617181920212223/** * 回收不需要的Item，并且将需要显示的Item从缓存中取出 */private void LayoutItems(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; // 当数量大于临界点才需要回收view boolean isMeetNum = getItemCount() &gt; CardConfig.MAX_SHOW_INDEX + 1; if (isMeetNum) &#123; for (int i = CardConfig.MAX_SHOW_INDEX + 1; i &lt; getItemCount(); i++) &#123; View child = recycler.getViewForPosition(i); removeAndRecycleView(child, recycler); &#125; &#125; // 展示需要展示的view for (int i = isMeetNum ? CardConfig.MAX_SHOW_INDEX : getItemCount() - 1; i &gt;= 0; i--) &#123; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); addView(scrap); //将这个item布局出来 layoutDecorated(scrap, mViewInfo.left, mViewInfo.top, mViewInfo.right, mViewInfo.bottom); int translateY = i * CardConfig.CARD_VERTICAL_GAP; ViewCompat.setTranslationY(scrap, -translateY); &#125;&#125; 这个方法中，将不需要展示的view全部remove，然后将需要展示的view布局出来。 2、使用ItemTouchHelper实现滑动​ ItemTouchHelper是一个为Recyclerview提供 Swipe、drag、drop事件的工具类。使用方法也很简单，推荐大家看泡网的这一片入门文章，思路很清晰。 ​ 本次项目中使用的是ItemTouchHelper本身提供的一个帮助类 SimpleCallback，使用方法其实很简单。它的构造参数有两个值，一个是dragDirs长按的方向，另一个是swipeDirs滑动的方向。可以看看SImpleCallBack的源码： 1234public SimpleCallback(int dragDirs, int swipeDirs) &#123; mDefaultSwipeDirs = swipeDirs; mDefaultDragDirs = dragDirs;&#125; ​ 而我们只需要滑动，所以构造参数中只需要实现 swipe 即可： 12//不支持长按拖拽，支持swipe，而且四个方向皆可以swipethis(0, ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT） ​ 然后应用此 ItemTouchHelper 即可： 123CardItemTouchHelperCallback cardCallback = new CardItemTouchHelperCallback(mRecyclerView, mRecyclerView.getAdapter(), list);ItemTouchHelper touchHelper = new ItemTouchHelper(cardCallback);touchHelper.attachToRecyclerView(mRecyclerView); ​ 到这里 Recyclerview已经实现了四个方向的滑动了，但滑动之后的操作还需要再实现一下。我们在 onSwiped(RecyclerView.ViewHolder viewHolder, int direction) 方法中实现 swipe之后的操作。这个方法有两个参数，viewHolder代表的就是此时滑动的viewholder，direction 代表的是这个view最终滑动的方向。在这个方法里，我们对数据源进行操作，然后刷新列表。 在Recyclerview的Adapter的数据刷新上，我使用了扩展包提供的 DiffUtils,是google提供的替换 notifyDataSetChanged()无脑刷 的方案。 ​ 最后在 onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) 方法中实现滑动时的动画。这个方法有多达七个参数，我来依次解释一下： c ，Recyclerview用来绘制children的画笔 recyclerView，额……就是所依赖的Recyclerview viewHolder，当下滑动的这个view的viewHolder dX、dY，手指在控制滑动的时候，此view水平X轴和垂直Y轴位移的距离，单位像素 actionState，标明此时是长按拖拽还是单纯的swipe isCurrentlyActive，标明此时滑动的view是处于手指控制状态，还是手指松开后的回弹动画状态 ​ 了解了参数之后，在这个方法中就可以实现滑动时的动画了。SimpleCallBack 默认的对滑动距离判断的条件是，水平方向是Recyclerview宽的一半，垂直方向是Recyclerview高的一半。 1234//这个方法返回的值就是默认的阙值，想要更灵敏的话只需在自定义CallBack中重写这个方法，将值变小。更迟钝的话则反之public float getSwipeThreshold(ViewHolder viewHolder) &#123; return .5f;&#125; ​ 撸出来的代码如下： 1234567891011121314151617181920212223242526272829303132@Override public void onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) &#123; super.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive);// Log.d(TAG, &quot;onChildDraw dX : &quot; + dX);// Log.d(TAG, &quot;onChildDraw dY : &quot; + dY); Log.d(TAG, &quot;onChildDraw isCurrentlyActive: &quot; + isCurrentlyActive); if (mItemW == 0) &#123;// Log.d(TAG, &quot;onChildDraw getAdapterPosition : &quot; + viewHolder.getAdapterPosition()); mItemW = viewHolder.itemView.getWidth(); mHorJudgeDistance = recyclerView.getWidth() * getSwipeThreshold(viewHolder); mVerJudgeDistance = recyclerView.getHeight() * getSwipeThreshold(viewHolder); &#125; float ratio; if (Math.abs(dX) &gt; Math.abs(dY)) &#123; //以宽为判定基准 ratio = Math.abs(dX) / mHorJudgeDistance; &#125; else &#123; //以高为判定基准 ratio = Math.abs(dY) / mVerJudgeDistance; &#125; float realRatio = ratio &gt;= 1f ? 1f : ratio; ViewCompat.setAlpha(viewHolder.itemView, 1 - realRatio); boolean isMeetNum = recyclerView.getLayoutManager().getItemCount() &gt; CardConfig.MAX_SHOW_COUNT + 1; int maxJudge = isMeetNum ? CardConfig.MAX_SHOW_COUNT - 1 : (recyclerView.getLayoutManager().getItemCount() - 1); for (int i = 1; i &lt;= maxJudge; i++) &#123; View itemView = recyclerView.findViewHolderForAdapterPosition(i).itemView; float v = i * CardConfig.CARD_VERTICAL_GAP - realRatio * CardConfig.CARD_VERTICAL_GAP; ViewCompat.setTranslationY(itemView, -v); &#125; &#125; 3、使用ItenAnimator实现回滚动画​ ItemAnimator 我没有选择实现，而是使用了现成的轮子recyclerview-animators，没有选择远程库引入。而是将源代码copy进来，再进行了适当性的修改。 12mRecyclerView.setItemAnimator(new SlideAnimator());mRecyclerView.getItemAnimator().setAddDuration(250); ​ OK，到这里基本上就大功告成了，只剩下一些小细节和bug处理一下即可。在CallBack 类的 onSwipe 方法中将 direction 赋值到一个静态变量中，然后在 SlideAnimator 根据不同的方向实现不同的动画。 ​ 在实现过程中，我发现回滚动画的那个view居然不是滑走的view，就使用了一个单例来管理数据。动画开始时将数据设置为滑走的view的数据，动画结束后再将动画view的数据还原。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Overrideprotected void preAnimateAddImpl(RecyclerView.ViewHolder holder) &#123; Log.d(TAG, &quot;preAnimateAddImpl: &quot; + holder.itemView.getTag().toString()); DataExchangeMgr.getInstance().saveOrignData((int) holder.itemView.getTag(R.id.view_data)); //根据不同的方向设置不同的初始值 if (isHorizDirection()) &#123; int width = holder.itemView.getRootView().getWidth(); ViewCompat.setTranslationX(holder.itemView, CardConfig.sViewholderDirection == ItemTouchHelper.LEFT ? -width : width); &#125; else &#123; int height = holder.itemView.getRootView().getHeight(); ViewCompat.setTranslationY(holder.itemView, CardConfig.sViewholderDirection == ItemTouchHelper.UP ? -height : height); &#125;&#125;@Overrideprotected void animateAddImpl(final RecyclerView.ViewHolder holder) &#123; //根据不同的方向选择不同的动画 ViewPropertyAnimatorCompat viewPropertyAnimatorCompat = ViewCompat.animate(holder.itemView) .setDuration(getAddDuration()) .setInterpolator(mInterpolator) .setListener(new DefaultAddVpaListener(holder) &#123; @Override public void onAnimationStart(View view) &#123; super.onAnimationStart(view); //将此view数据设置为滑开的数据 ((ImageView) mViewHolder.itemView.findViewById(R.id.show_img)).setImageResource(DataExchangeMgr.getInstance().getCurrentData()); &#125; @Override public void onAnimationCancel(View view) &#123; super.onAnimationCancel(view); //数据还原 ((ImageView) mViewHolder.itemView.findViewById(R.id.show_img)).setImageResource(DataExchangeMgr.getInstance().getOrignalData()); &#125; @Override public void onAnimationEnd(View view) &#123; super.onAnimationEnd(view); //数据还原 ((ImageView) mViewHolder.itemView.findViewById(R.id.show_img)).setImageResource(DataExchangeMgr.getInstance().getOrignalData()); &#125; &#125;) .setStartDelay(50); if (isHorizDirection()) &#123; viewPropertyAnimatorCompat .translationX(0) .start(); &#125; else &#123; viewPropertyAnimatorCompat .translationY(0) .start(); &#125;&#125;private boolean isHorizDirection() &#123; return CardConfig.sViewholderDirection == ItemTouchHelper.LEFT || CardConfig.sViewholderDirection == ItemTouchHelper.RIGHT;&#125; 最后感兴趣的可以看看代码，奉上GitHub地址。InfinateCard","path":"2017/05/10/android-infinite-card/","date":"05-10","excerpt":"","tags":[{"name":"Android","slug":"Android","permalink":"https://yoursite.com/tags/Android/"},{"name":"交互体验","slug":"交互体验","permalink":"https://yoursite.com/tags/交互体验/"}],"preview":"https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/20170510-blog-header-bg.jpg"},{"title":"Android萤火虫飞舞粒子效果","text":"GitHub地址 原创文章，转载请注明出处 萤火虫飞舞粒子效果 本项目中我提供了两种方案，最终呈现的效果如下： 先奉上GitHub地址戳这里，有兴趣的同鞋star一下咯 实现原理Android的粒子效果、粒子动画，已经有很多开源的轮子了。作为一个坚定的轮子主义者，我google了大半天，却没有找到这种类似于萤火虫飞舞的效果。只好自己来实现这种效果。 相比较普通的View，SurfaceView更加适合这种不断变化的画面，所以选择SurfaceView来实现。现在把思路再重新梳理一下： 大小不同的粒子在区域内随机分布 粒子做无规则运动，然后消失 粒子区域内随机分布这个简单，我们在callBack的方法内直接循环生成一个粒子的数组即可。方位的话使用Random即可。 1234567891011121314151617if (mCircles.size() == 0) &#123; for (int i = 0; i &lt; MAX_NUM; i++) &#123; FloatParticleLine f = new FloatParticleLine(getF() * mMeasuredWidth, getF() * mMeasuredHeight, mMeasuredWidth, mMeasuredHeight); f.setRadius(mRandom.nextInt(2) + 1.2f); mCircles.add(f); &#125;&#125;private float getF() &#123; float v = mRandom.nextFloat(); if (v &lt; 0.2f) &#123; return v + 0.2f; &#125; else if (v &gt;= 0.85f) &#123; return v - 0.2f; &#125; else &#123; return v; &#125; &#125; getF（）方法是限制在区域内取值，mMeasuredWidth、mMeasuredHeight为SurfaceView的宽和高。 这里的宽和高在粒子对象FloatParticleLine，内会用到。 然后我们在创建一个线程，在run（）方法内做无线循环的绘制即可，为了避免无意义的绘制，可以使用Thread.sleep方法来控制帧数。 1234567891011121314151617181920212223while (isRun) &#123; try &#123; mCanvas = mHolder.lockCanvas(null); if (mCanvas != null) &#123; synchronized (mHolder) &#123; // 清屏 mCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR); for (FloatParticleLine circle : mCircles) &#123; circle.drawItem(mCanvas); &#125; // 控制帧数 Thread.sleep(25); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (mCanvas != null) &#123; mHolder.unlockCanvasAndPost(mCanvas); &#125; &#125;&#125; isRun的变量我们会在SurfaceView内callBack的surfaceDestroyed方法中置为false 粒子做无规则运动 方案一 其实看到这种粒子效果，首先应该想到的就是Canvas了。 在SurfaceView里就是通过不断地循环调用FloatParticleLine类的drawItem（）方法来实现粒子的运动。我第一种方案的实现，就是每一个粒子在被创建出来的时候，就随机选择一个方向开始运动，滑过一定的轨迹之后让其消失就好了。 至于怎么选择随机方向，我这里的做法是，分别随机生成一个x和y轴上的递增或者递减的数值，然后每次在前一次绘制的基础上，x和y分别递增递减，直到运动到屏幕边缘或者是规定的运动距离满足了再消失即可。 12345678910111213//随机生成参数private void setRandomParm() &#123; // 2017/5/2-上午10:47 x和y的方向 mIsAddX = mRandom.nextBoolean(); mIsAddY = mRandom.nextBoolean(); // 2017/5/2-上午10:47 x和y的取值 mDisX = mRandom.nextInt(2) + 0.2f; mDisY = mRandom.nextInt(2) + 0.3f; // 2017/5/2-上午10:47 内部区域的运动最远距离 mDistance = mRandom.nextInt((int) (0.25f * mWidth)) + (0.125f * mWidth);&#125; 绘制图形： 1234567891011121314151617181920212223242526272829303132public void drawItem(Canvas canvas) &#123; if (mX == mStartX) &#123; mPaint.setAlpha(ALPHA_MAX); &#125; //绘制 canvas.drawCircle(mX += getPNValue(mIsAddX, mDisX), mY += getPNValue(mIsAddY, mDisY), mRadius, mPaint); //内部区域运动到一定距离消失 if (judgeInner()) &#123; float gapX = Math.abs(mX - mStartX); float ratio = 1 - (gapX / mDistance); mPaint.setAlpha((int) (255 * ratio)); mRadius = mStartRadius * ratio; if (gapX &gt;= mDistance || mY - mStartY &gt;= mDistance) &#123; resetDisXY(); return; &#125; return; &#125; //外部区域运动到屏幕边缘消失 if (judgeOutline()) &#123; resetDisXY(); &#125;&#125;private void resetDisXY() &#123; setRandomParm(); mPaint.setAlpha(0); mX = mStartX; mY = mStartY; mRadius = mStartRadius; &#125; judgeInner()和judgeOutline()是判断区域的方法，内部区域的点和外部区域的店消失时机不同 在透明度为0也就是粒子消失时，让粒子回到原点，再重新选择一个方向，进行下一步运动轨迹。 方案二 方案二粒子做的运动是贝塞尔曲线，函数实在网上找到的一个函数。每当粒子做完一次曲线运动后，再随机生成一段新的贝塞尔曲线即可。 思路和方案一的思路都是一样的，无非就是运动的轨迹不同而已。 总结做完之后回头再看，发现这个项目的原理其实并不难，可以说是简单了。但刚开始起步的时候真的还是比较懵的，原因就是没有思路。 所以做任何效果，思路最重要。","path":"2017/04/28/android-firefly/","date":"04-28","excerpt":"","tags":[{"name":"Canvas动画","slug":"Canvas动画","permalink":"https://yoursite.com/tags/Canvas动画/"},{"name":"Android","slug":"Android","permalink":"https://yoursite.com/tags/Android/"}],"preview":"https://raw.githubusercontent.com/JadynAi/oldpage.io/master/img/20170428-blog-header-bg.jpg"},{"title":"Hello World","text":"Hello World","path":"2017/04/28/hello-world/","date":"04-28","excerpt":"","tags":[]}]}